% В этом файле следует писать текст работы, разбивая его на
% разделы (section), подразделы (subsection) и, если нужно,
% главы (chapter).

% Предварительно следует указать необходимую информацию
% в файле SETUP.tex

\input{preamble.tex}

\begin{document}

\Intro

Здесь вам нужно писать введение. Некоторые часто используемые команды приведены в качестве примера ниже (и варианты — в комментариях).

Your introduction goes here! Some examples of commonly used commands and features are listed below, to help you get started. If you have a question, please use the help menu (``?'') on the top bar to search for help or ask us a question.

% Если typeOfWork в SETUP.tex задан как 2 или 3, то начинать
% надо не с section (раздел), а с главы (chapter)
\chapter{Синтаксис и семантика языка программирования}
В данной главе будет приведена семантика и синтаксис языка программирования, описанного в работах ~\cite{tms_article} и ~\cite{opacity_article}. В данный язык введен ряд ограничений. В программе запрещены явное прерывание выполнения транзакций, вложенные атомарные блоки и транзакции. 

\section{Синтаксис}
Рассмотрим язык программирования, в котором программа $P$ представляется в виде параллельной композиции потоков  $C_t,\, t \in ThreadId=\{1, \ldots, m \}$: $P = C_1 \parallel \ldots \parallel C_m$. У каждого потока $t \in Threads$ есть набор локальных переменных $LVar_t = \{x,y, \ldots \}$ и общий набор глобальных переменных $GVar = \{g, \ldots \}$. Все переменные целого типа. Обозначим множество всех переменных программы как $Var = GVar \uplus \biguplus_{t = 1}^m LVar_{t}$. У потоков также есть доступ к транзакционной памяти, которая управляет фиксированным набором объектов $Obj = \{o, \ldots \}$. У каждого объекта есть множество методов, которые могут быть вызваны потоками. Предполагается, что каждый метод принимает на входе целое значение и возвращает в качестве результата целое значение. У всех объектов транзакционной памяти один и тот же набор методов $Method = \{f, \ldots \}$. Синтаксис команд $C$ рассматриваемого языка программирования стандартный. $C$ может иметь вид: $$ c \,|\, C;C \,|\, while \, (b) \, do \, C \,|\, if \, (b) \, then \, C\, else \, C \, | \, x := atomic \, \{ C \} \, | \, x := o.f(e), $$ где $b$ и $e$ обозначают логические и целые операции над локальными переменными. Синтаксис включает примитивную команду $C$ из множества $PComm$, последовательную композицию, условный оператор, цикл, атомарный блок и вызов методов объектов. Примитивные команды исполняются атомарно. Множество $PComm$ включает присваивания значений локальным и глобальным переменным и специальную операцию fault, которая останавливает исполнение программы в ошибочном состоянии. Следовательно, fault вызывается при некорректных вычислениях, таких как деление на ноль.

Атомарный блок $x := atomic \, \{C\}$ исполняет $C$ как транзакцию, которую транзакционная память может зафиксировать или оборвать. Решение системы ($aborted$ или $committed$) будет записано в локальную переменную $x$. 

В данный языке программирования введено ограничение доступа к переменным и объектам транзакционной памяти. Вызов методов объектов транзакционной памяти возможен только внутри транзакций, доступ к глобальным переменным осуществляется только вне транзакций. Локальные переменные доступны в обоих случаях, но потокам запрещен доступ к локальным переменным других потоков.

Для формального описания ограничения доступа примитивных команд к переменным, множество $PComm - \{fault\}$ разделяется на два подмножества: $\biguplus_{t=1}^m (LPcomm_t \uplus GPcomm_t)$. Команды из подмножества $LPcomm_t$ имеют доступ только к локальным переменным потока $t$ ($LVar_t$). У команд из подмножества $GPcomm_t$ есть доступ как к локальным переменным потока $t$, так и к глобальным переменным программы ($LVar_t \uplus GVar$). 

\section{Модель вычисления}
\theoremstyle{definition}
\newtheorem{defn}{Definition}
Прежде чем перейти к определению семантики данного языка программирования, введём основные термины. 

\begin{defn} Пусть $ActionId$ --- множество идентификаторов действий. Действие интерфейса $\psi$ транзакционной памяти ($TM$) может иметь одно из следующих представлений:\\

\begin{tabular}{llr}
\hline
Запрос  & Ответ \\
\hline
$(a, t, txbegin)$ & $(a, t, OK)$ & $(a, t, aborted)$     \\
$(a, t, txcommit)$ & $(a, t, committed)$ & $(a, t, aborted)$ \\
$(a, t, call \, o.f(n))$ & $(a, t, ret (n') \, o.f)$ & $(a, t, aborted)$ \\
\hline
\end{tabular}\\
\\
где $a \in ActionId, t \in ThreadId, o \in Obj, f \in Method$ и $n,n' \in \mathbb{Z}$. Примитивное действие $\chi$ обозначается как $(a, t, c)$, где $c \in PComm$. Все остальные действия обозначим $\varphi$.
\end{defn}
Посредством действий интерфейса программа взаимодействует с транзакционной памятью.
Действие $txbegin$ генерируется после входа в атомарный блок, а действие $txcommit$ при попытке фиксации изменений после выхода из атомарного блока. Действия $call$ и $ret$ обозначают вызов метода транзакционного объекта и результат вызова. $n$ и $n'$ - входной параметр метода и результат вызова соответственно. $TM$ может прервать транзакцию в ответ на запрос программы.

\begin{defn} След $\tau$ --- конечная последовательность действий, удовлетворяющих следующим условиям:
\begin{enumerate}
  \item Каждое действие в $\tau$ обладает уникальным идентификатором: $if \, \tau = \tau_1 (\alpha_1,\_,\_) \tau_2 (\alpha_2,\_,\_) \tau_3 \, then \, \alpha_1 \neq \alpha_2$.   
  \item За командой $fault$ не следуют другие действия: если $\tau = \tau'\varphi$, тогда $\tau'$ не содержит $fault$ действие.
  \item Запросы и ответы верно сопоставлены.
  \item $\tau \mid_t$ для $\forall t$ не содержит запросы, следующие сразу за примитивными действиями.
  \item Действия, обозначающие начало и конец транзакции, верно сопоставлены: в проекции следа $\tau \mid_t$ для $\forall t$ на $txbegin, committed$ и $aborted$ действия для каждого $txbegin$ действия содержится $committed$ или $aborted$ действие.
  \item Действия $call$ и $ret$ встречаются только внутри транзакций: если $\tau \mid_t = \tau_1\psi\tau_2$ для $\forall t$, где $\psi$ --- $call$ или $ret$ действие, тогда $\tau_1 = \tau_1'\psi'\tau_1''$ для некоторого $\psi' = (\_,t,txbegin)$, и $\tau'$,  $\tau''$ не содержат $committed$ или $aborted$ действий.
  \item У команд в $\tau$ нет доступа к локальным переменным других потоков: если $(\_,t,c) \in \tau$, тогда $c \in LPcomm_t \uplus GPcomm_t \uplus \{ fault\}$.
  \item У команд в $\tau$ нет доступа к глобальным переменным внутри транзакций: если $\tau = \tau_1(\_,t,c)\tau_2$ для $c \in GPcomm_t$, тогда $\tau_1 \neq \tau_1'(\_,t,txbegin)\tau_1''$ при $\tau_1''$ не содержащем $committed$ или $aborted$ действия.
\end{enumerate}

\end{defn}

Обозначим множество следов $Trace$. След, содержащий только действия интерфейса называется историей. Транзакционная память $\mathcal{T}$ --- множество историй, замкнутых относительно операции переименования идентификатора и относительно префиксов историй.

Введём ряд обозначений. Пусть незначительные выражения обозначаются как \_; $i$ элемент следа $\tau$ --- $\tau(i)$; $\tau\mid_t$ --- проекция следа $\tau$ на действия вида $(\_,t,\_)$; $|\tau|$ --- длина следа; $\tau_1\tau_2$ --- конкатенация следов $\tau_1$, $\tau_2$. Пустую последовательность действий обозначим как $\varepsilon$.   

Транзакция T --- непустой след, содержащий действия, принадлежащие одному потоку, начинающийся с $txbegin$ действия и только последнее действие следа может быть $committed$ или $aborted$ действием. Рассмотрим статусы транзакций. Транзакция $T$ зафиксированная, если завершается $committed$ действием. Транзакция $T$ прерванная, если завершается $aborted$ действием. Транзакция $T$ ожидает фиксацию, если завершается $txcommit$ действием. Транзакция $T$ действующая во всех остальных случаях. Также транзакция считается завершенной, если она прерванная или зафиксированная. Транзакция видимая, если содержит $txcommit$ действие. След $\tau$ содержит транзакцию $T$, $T \in \tau$, если $\tau\mid_t = \tau_1T\tau_2$ для некоторого $t$, $\tau_1$ и $\tau_2$, при этом либо $T$ --- завершенная транзакция, либо $\tau_2$ пустой след. Обозначим $tx(\tau)$ --- множество всех транзакций, принадлежащих следу $\tau$. Множество зафиксированные, прерванных, ожидающих фиксации, действующих и видимых транзакций обозначим как $committed(\tau), aborted(\tau), pending(\tau), live(\tau), visible(\tau)$ соответственно. Обозначим транзакцию следа $\tau$, содержащую действие $\varphi$, как $txof(\varphi, \tau)$.

\section{Семантика}  
\counterwithout{figure}{chapter}
Для того, чтобы определить семантику данного языка программирования, определим множество следов исполнения программы. Состоянием программы $s$ будем называть значения всех переменных программы: $s \in State = Var \to \mathbb{Z} $. Семантика программы $P = C_1 \parallel \ldots \parallel C_m$ задана множеством следов $\llbracket P, \mathcal{T} \rrbracket (s) \subseteq Trace$, полученных при исполнении программы, взаимодействующей с транзакционной памятью $\mathcal{T}$ при исходном состоянии $s$. Чтобы определить это множество, для начала определим множество $\llbracket P \rrbracket (s) \subseteq Trace$ без ограничений взаимодействия с транзакционной памятью.

Для формального описания множества $\llbracket P \rrbracket (s)$, определим множество $A(P)$, состоящее из всех следов, которые могут быть исполнены. Например, если поток выполняет команду $x := 1;\, if \, (x = 1) \, than \, y := 1 \, else \, y := 2$, где $x,y$ --- локальные переменные, тогда $A(P)$ будет содержать след, в котором $y := 2$, вместо $y := 1$. Для того, чтобы отфильтровать подобные случаи, вводится функция $eval: State \times Trace \to \mathcal{P}(State) \cup \{\lightning\}$, которая принимает на входе в качестве параметров исходное состояние и след и возвращает множество состояний, полученных при выполнении действий следа. Если след некорректный или завершается командой $fault$, то множество состояний пустое или $\{\lightning\}$ соответственно. Следовательно, $\llbracket P \rrbracket (s) = \{\tau \in A(P) \, | \, eval(s,\tau) \neq \emptyset \}$.
\begin{figure}
\begin{flalign*}
&A'(c)t = \{(\_,t,c)\} \\ 
&A'(C_1;C_2)t = \{\tau_1\tau_2 \,| \, \tau_1 \in A'(C_1)t \land \tau_2 \in A'(C_2)t \}\\
&A'(if \, (b) \, then \, C_1 \, else \, C_2)t =  \{(\_,t,assume(b))\tau_1 \, | \, \tau_1 \in A'(C_1)t \} \, \cup \\
& \{ (\_, t, assume(\neg b))\tau_2 \, | \, \tau_2 \in A'(C_2)t\}
&A'(while \, (b) \, do \, C)t = \{ ((\_,t,assume(b))(A'(C)t))^*(\_,t,assume(\neg b)) \} \\
&A'(x := o.f(e))t = \\ 
&\{ (\_,t, assume(e =n))(\_,t, call \, o.f(n))(\_,t,ret(n') \, o.f)(\_,t,x:=n') \, | \, n, n' \in \mathbb{Z}\} \, \cup \\
&\{(\_,t,assume(e=n))(_,t,call \, o.f(n))(\_,t,aborted) \, | \, n \in \mathbb{Z} \} \\
&A'(x:=atomic\{C\})t = \{ (\_,t,txbegin)(\_,t,aborted)(\_,t,x:= aborted) \} \, \cup \\ 
&\{(\_,t,txbegin)(\_,t,OK)\tau(\_,t,txcommit)(\_,t,r)(\_,t,x:= r) \, | \, \tau \in A'(C)t \, \land \, \\
&(\_,t,aborted) \notin \tau \, \land \, (r = committed \lor r = aborted) \} \, \cup \\ 
&\{(\_,t,txbegin)(\_,t,OK)\tau(\_,t,aborted)(\_,t,x:= aborted) \, | \, \tau(\_,t,aborted)\tau' \in A'(C)t \, \land \, \\
&(\_,t,aborted) \notin \tau\}\\
&A'(C_1 \parallel \ldots \parallel C_m) = \\
&prefix(\bigcup \{ interleave(\tau_1,\ldots, \tau_m) \, | \, \forall t \, 1 \leq t \leq m \implies \tau_t \in A'(C_t)t \})\\
&A(P) = A'(P) \cap Trace
\end{flalign*}
\caption{Определение множества $A(P)$}
\label{fig:actions}
\end{figure}

Определим множество $A(P)$. Функция $A'(P)$ на рисунке ~\ref{fig:actions} ставит в соответствие командам и программам множество действий, которое они могут исполнить. $A'(P)$ может содержать последовательность действий, которая не является следом программы. Поэтому множество $A(P)$ получаем пересечением множеств $A'(P)$ и $Trace$. $A'(C)t$ --- множество последовательностей действий, полученных при выполнении команды $C$ потоком $t$. Для построения множества $A'(P)$, строим множество чередованием последовательностей действий потоков программы. $A'(P)$ --- множество префиксов последовательностей действий, полученных на предыдущем шаге.

Далее подробнее рассмотрим рисунок ~\ref{fig:actions}. $A'(c)t$ возвращает в качестве результата множество, состоящее из действия примитивной команды $c$. $A'(C_1;C_2)t$ соединяет все возможные действия последовательностей, соответствующих $C_1$ и $C_2$. Оценка условий в операторах $if$ и $while$ осуществляется посредством примитивной команды $assume \in LPcomm_t$. Команда $assume(b)$ не выполняет ни каких действий, если $b$ ($b$ --- выражение логического типа над локальными переменными потока $t$) истинно, иначе останавливает вычисления. Таким образом, нужная ветка в операторе $if$ выбирается с помощью действия $assume$. Все возможные итерации цикла $while$ определены с помощью оператора Клини $^*$.

Множество последовательностей действий вызова метода объекта транзакционной памяти включает последовательности, в которых метод был выполнен успешно, и в результате выполнения которого транзакция была прервана. Множество последовательностей действий выполнения атомарного блока $x := atomic\{C\}$ содержит последовательности, в которых команда $C$ прервана во время выполнения, и в которых $C$ выполняется до завершения.

Рассмотрим семантику примитивных команд $c \in PComm - \{fault\}$. Функция $\llbracket c \rrbracket$ определяет, как состояние программы меняется после выполнения команды $c$. Семантика команды $c \in LPcomm_t$ задана функцией $\llbracket c \rrbracket: (LVar_t \to \mathbb{Z}) \to \mathcal{P}(LVar_t \to \mathbb{Z})$. Семантика команды $c \in GPcomm_t$ задана функцией $\llbracket c \rrbracket: ((LVar_t \uplus GVar) \to \mathbb{Z}) \to \mathcal{P}((LVar_t \uplus GVar)  \to \mathbb{Z})$. Функция $c$ --- недетерминированная.

Функция $q$ ставит в соответствие переменной, к которой у команды $c$ есть доступ, её значение. Рассмотрим семантику примитивной команды присваивания:
$$\llbracket x:=g \rrbracket(q) = \{ q[x \mapsto q(g) ] \}.$$ Значения функции $q[x \mapsto q(g) ]$ совпадают со значениями $q$ за исключением значения переменной $x$, которая принимает значение $q(g)$.

\counterwithout{equation}{chapter}
Приведем семантику команды $assume$:
\begin{equation}
  \llbracket assume(x=n)\rrbracket(q)=\begin{cases}
    \{q\}, & \text{if $q(x)=n$};\\
    \emptyset, & \text{otherwise}.
  \end{cases}
\end{equation}
Для того, чтобы определить функцию $\llbracket c \rrbracket$ для состояния программы, условимся, что значения переменных, к которым у команды $c$ нет доступа, остаются без изменений. Если $c$ завершается с ошибкой, то в качестве результата возвращается $\lightning$. Например, если $c \in LPcomm_t$, тогда: $$\llbracket c \rrbracket (s) = \{s \mid_{LVar\backslash LVar_t} \uplus \, q  \,| \, q \in \llbracket c \rrbracket (s \mid_{LVar_t}) \},$$ $$\llbracket fault \rrbracket (s) = \lightning.$$

Рассмотрим функцию оценки корректности следа. Используя семантику примитивных команд, определим корректность одного действия при состоянии программы $s$:
$$eval: State \times Action \to \mathcal{P}(State) \cup \{ \lightning\} $$
$$eval(s,(\_,t,c)) = \llbracket c\rrbracket (s);$$
$$eval(s,\psi) = \{s\}.$$
Далее определим функцию $eval$ для следа:
$$eval: State \times Trace \to \mathcal{P}(State) \cup \{ \lightning\} $$
\begin{equation}
  eval(s,\tau)=\begin{cases}
    \emptyset, & \text{if $\tau = \tau'\varphi \land eval(s, \tau') = \emptyset$};\\
    evalna(s, \tau \mid_{\neg abortact}), & \text{otherwise},
  \end{cases}
\end{equation}

\begin{equation}
     evalna(s,\tau)=\begin{cases}
    \{s\}, & \text{if $\tau =  \varepsilon$};\\ 
     \{s'' \in eval(s', \varphi) \, | \, s' \in  evalna(s, \tau') \}, & \text{if $\tau = \tau'\varphi$}.
   \end{cases}
  \end{equation}

$\tau \mid_{\neg abortact}$ --- след, полученный из следа $\tau$ удалением всех действий внутри прерванных транзакций. Множество состояний, полученное в результате анализа следа $\tau$ при состоянии программы $s$, вычисляется с помощью функции $evalna(s, \tau)$. Так как в данной модели вычисления после прерывания выполнения транзакций значения переменных принимают свои прежние значения, то функция $evalna(s, \tau)$ игнорирует действия внутри прерванных транзакций. Однако, последовательность действия внутри прерванных транзакций может быть некорректной. Поэтому функция $eval(s,\tau)$ рекурсивно проверяет каждый префикс следа $\tau$.

Благодаря функции $eval$ множество $\llbracket P \rrbracket(s)$ будет содержать только корректные следы выполнения программы.   

\chapter{Результаты}
 
\section{Доказательство теоремы 1 (Необходимость)}
\theoremstyle{plain}
\newtheorem{lem}{Lemma}
\begin{lem}

\end{lem}

\section{Доказательство теоремы 1 (Достаточность)}


\Conc




% Печать списка литературы (библиографии)
\printbibliography[heading=bibintoc%
    %,title=Библиография % если хочется это слово
]
% Файл со списком литературы: biblio.bib
% Подробно по оформлению библиографии:
% см. документацию к пакету biblatex-gost
% http://ctan.mirrorcatalogs.com/macros/latex/exptl/biblatex-contrib/biblatex-gost/doc/biblatex-gost.pdf
% и огромное количество примеров там же:
% http://mirror.macomnet.net/pub/CTAN/macros/latex/contrib/biblatex-contrib/biblatex-gost/doc/biblatex-gost-examples.pdf

\end{document}
