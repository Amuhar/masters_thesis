% В этом файле следует писать текст работы, разбивая его на
% разделы (section), подразделы (subsection) и, если нужно,
% главы (chapter).

% Предварительно следует указать необходимую информацию
% в файле SETUP.tex

\input{preamble.tex}

\begin{document}

\Intro

Здесь вам нужно писать введение. Некоторые часто используемые команды приведены в качестве примера ниже (и варианты — в комментариях).

Your introduction goes here! Some examples of commonly used commands and features are listed below, to help you get started. If you have a question, please use the help menu (``?'') on the top bar to search for help or ask us a question.

% Если typeOfWork в SETUP.tex задан как 2 или 3, то начинать
% надо не с section (раздел), а с главы (chapter)
\chapter{Синтаксис и семантика языка программирования}
В данной главе будет приведена семантика и синтаксис языка программирования, описанного в работах ~\cite{tms_article} и ~\cite{opacity_article}. В данный язык введен ряд ограничений. В программе запрещены явное прерывание выполнения транзакций, вложенные атомарные блоки и транзакции. 

\section{Синтаксис}
Рассмотрим язык программирования, в котором программа $P$ представляется в виде параллельной композиции потоков  $C_t,\, t \in ThreadId=\{1, \ldots, m \}$: $P = C_1 \parallel \ldots \parallel C_m$. У каждого потока $t \in Threads$ есть набор локальных переменных $LVar_t = \{x,y, \ldots \}$ и общий набор глобальных переменных $GVar = \{g, \ldots \}$. Все переменные целого типа. Обозначим множество всех переменных программы как $Var = GVar \uplus \biguplus_{t = 1}^m LVar_{t}$. У потоков также есть доступ к транзакционной памяти, которая управляет фиксированным набором объектов $Obj = \{o, \ldots \}$. У каждого объекта есть множество методов, которые могут быть вызваны потоками. Предполагается, что каждый метод принимает на входе целое значение и возвращает в качестве результата целое значение. У всех объектов транзакционной памяти один и тот же набор методов $Method = \{f, \ldots \}$. Синтаксис команд $C$ рассматриваемого языка программирования стандартный. $C$ может иметь вид: $$ c \,|\, C;C \,|\, while \left (b\right) \, do \, C \,|\, if \left (b\right) then \, C\, else \, C \, | \, x := atomic \, \{ C \} \, | \, x := o.f(e), $$ где $b$ и $e$ обозначают логические и целые операции над локальными переменными. Синтаксис включает примитивную команду $c$ из множества $PComm$, последовательную композицию, условный оператор, цикл, атомарный блок и вызов методов объектов. Примитивные команды исполняются атомарно. Множество $PComm$ включает присваивания значений локальным и глобальным переменным и специальную операцию fault, которая останавливает исполнение программы в ошибочном состоянии. Следовательно, fault вызывается при некорректных вычислениях, таких как деление на ноль.

Атомарный блок $x := atomic \, \{C\}$ исполняет $C$ как транзакцию, которую транзакционная память может зафиксировать или прервать. Решение системы ($aborted$ или $committed$) будет записано в локальную переменную $x$. 

В данный языке программирования введено ограничение доступа к переменным и объектам транзакционной памяти. Вызов методов объектов транзакционной памяти возможен только внутри транзакций, доступ к глобальным переменным осуществляется только вне транзакций. Локальные переменные доступны в обоих случаях, но потокам запрещен доступ к локальным переменным других потоков.

Для формального описания ограничения доступа примитивных команд к переменным, множество $PComm - \{fault\}$ разделяется на два подмножества: $\biguplus_{t=1}^m (LPcomm_t \uplus GPcomm_t)$. Команды из подмножества $LPcomm_t$ имеют доступ только к локальным переменным потока $t$ ($LVar_t$). У команд из подмножества $GPcomm_t$ есть доступ как к локальным переменным потока $t$, так и к глобальным переменным программы ($LVar_t \uplus GVar$). 

\section{Модель вычисления}
Прежде чем перейти к определению семантики данного языка программирования, введём основные термины. 

\begin{mydefinition}\label{def1} Пусть $ActionId$ --- множество идентификаторов действий. Действие интерфейса $\psi$ транзакционной памяти ($TM$) может иметь одно из следующих представлений:\\

\begin{tabular}{llr}
\hline
Запрос  & Ответ \\
\hline
$(a, t, txbegin)$ & $(a, t, OK)$ & $(a, t, aborted)$     \\
$(a, t, txcommit)$ & $(a, t, committed)$ & $(a, t, aborted)$ \\
$(a, t, call \, o.f(n))$ & $(a, t, ret (n') \, o.f)$ & $(a, t, aborted)$ \\
\hline
\end{tabular}\\
\\
где $a \in ActionId, t \in ThreadId, o \in Obj, f \in Method$ и $n,n' \in \mathbb{Z}$. Примитивное действие $\chi$ обозначается как $(a, t, c)$, где $c \in PComm$. Все остальные действия обозначим $\varphi$.
\end{mydefinition}
Посредством действий интерфейса программа взаимодействует с транзакционной памятью.
Действие $txbegin$ генерируется после входа в атомарный блок, а действие $txcommit$ при попытке фиксации изменений после выхода из атомарного блока. Действия $call$ и $ret$ обозначают вызов метода транзакционного объекта и результат вызова. $n$ и $n'$ - входной параметр метода и результат вызова соответственно. $TM$ может прервать транзакцию в ответ на запрос программы.

\begin{mydefinition}\label{def2} След $\tau$ --- конечная последовательность действий, удовлетворяющих следующим условиям:
\begin{enumerate}
  \item Каждое действие в $\tau$ обладает уникальным идентификатором: $if \, \tau = \tau_1 (\alpha_1,\_,\_) \tau_2 (\alpha_2,\_,\_) \tau_3 \, then \, \alpha_1 \neq \alpha_2$.   
  \item За командой $fault$ не следуют другие действия: если $\tau = \tau'\varphi$, тогда $\tau'$ не содержит $fault$ действие.
  \item Запросы и ответы верно сопоставлены.
  \item $\tau|_t$ для $\forall t$ не содержит запросы, следующие сразу за примитивными действиями.
  \item Действия, обозначающие начало и конец транзакции, верно сопоставлены: в проекции следа $\tau|_t$ для $\forall t$ на $txbegin, committed$ и $aborted$ действия для каждого $txbegin$ действия содержится $committed$ или $aborted$ действие.
  \item Действия $call$ и $ret$ встречаются только внутри транзакций: если $\tau|_t = \tau_1\psi\tau_2$ для $\forall t$, где $\psi$ --- $call$ или $ret$ действие, тогда $\tau_1 = \tau_1'\psi'\tau_1''$ для некоторого $\psi' = (\_,t,txbegin)$, и $\tau'$,  $\tau''$ не содержат $committed$ или $aborted$ действий.
  \item У команд в $\tau$ нет доступа к локальным переменным других потоков: если $(\_,t,c) \in \tau$, тогда $c \in LPcomm_t \uplus GPcomm_t \uplus \{ fault\}$.
  \item У команд в $\tau$ нет доступа к глобальным переменным внутри транзакций: если $\tau = \tau_1(\_,t,c)\tau_2$ для $c \in GPcomm_t$, тогда $\tau_1 \neq \tau_1'(\_,t,txbegin)\tau_1''$ при $\tau_1''$ не содержащем $committed$ или $aborted$ действия.
\end{enumerate}

\end{mydefinition}

Обозначим множество следов $Trace$. След, содержащий только действия интерфейса, называется историей. Транзакционная память $\mathcal{T}$ --- множество историй, замкнутых относительно операции переименования идентификатора и относительно префиксов историй.

Введём ряд обозначений. Пусть незначительные выражения обозначаются как \_; $i$ элемент следа $\tau$ --- $\tau(i)$; $\tau|_t$ --- проекция следа $\tau$ на действия вида $(\_,t,\_)$; $|\tau|$ --- длина следа; $\tau_1\tau_2$ --- конкатенация следов $\tau_1$, $\tau_2$; $\tau\downharpoonleft_i$ --- префикс следа $\tau$, содержащий $i$ действий. Пустую последовательность действий обозначим как $\varepsilon$.

\begin{mydefinition}\label{def3} Два следа $\tau$ и $\tau'$ эквиваленты относительно идентификаторов, $\tau \equiv \tau'$,если $|\tau| = |\tau'|$ и для каждого $i = 1..|\tau|$ действия $\tau(i)$ и $\tau'(i)$ могут отличаться только идентификаторами.
\end{mydefinition}

Транзакция T --- непустой след, содержащий действия, принадлежащие одному потоку, начинающийся с $txbegin$ действия и только последнее действие следа может быть $committed$ или $aborted$ действием. Рассмотрим статусы транзакций. Транзакция $T$ зафиксированная, если завершается $committed$ действием. Транзакция $T$ прерванная, если завершается $aborted$ действием. Транзакция $T$ ожидает фиксацию, если завершается $txcommit$ действием. Транзакция $T$ действующая во всех остальных случаях. Также транзакция считается завершенной, если она прерванная или зафиксированная. Транзакция видимая, если содержит $txcommit$ действие. След $\tau$ содержит транзакцию $T$, $T \in \tau$, если $\tau|_t = \tau_1T\tau_2$ для некоторого $t$, $\tau_1$ и $\tau_2$, при этом либо $T$ --- завершенная транзакция, либо $\tau_2$ пустой след. Обозначим $tx(\tau)$ --- множество всех транзакций, принадлежащих следу $\tau$. Множество зафиксированныхх, прерванных, ожидающих фиксации, действующих и видимых транзакций обозначим как $committed(\tau), aborted(\tau), pending(\tau), live(\tau), visible(\tau)$ соответственно. Обозначим транзакцию следа $\tau$, содержащую действие $\varphi$, как $txof(\varphi, \tau)$.

\section{Семантика}  
\counterwithout{figure}{chapter}
Для того, чтобы определить семантику данного языка программирования, определим множество следов исполнения программы. Состоянием программы $s$ будем называть значения всех переменных программы: $s \in State = Var \to \mathbb{Z} $. Семантика программы $P = C_1 \parallel \ldots \parallel C_m$ задана множеством следов $\llbracket P, \mathcal{T} \rrbracket (s) \subseteq Trace$, полученных при исполнении программы, взаимодействующей с транзакционной памятью $\mathcal{T}$ при исходном состоянии $s$. Чтобы определить это множество, для начала определим множество $\llbracket P \rrbracket (s) \subseteq Trace$ без ограничений взаимодействия с транзакционной памятью.

Для формального описания множества $\llbracket P \rrbracket (s)$, определим множество $A(P)$, состоящее из всех следов, которые могут быть исполнены. Например, если поток выполняет команду $x := 1;\, if \, (x = 1) \, than \, y := 1 \, else \, y := 2$, где $x,y$ --- локальные переменные, тогда $A(P)$ будет содержать след, в котором $y := 2$, вместо $y := 1$. Для того, чтобы отфильтровать подобные случаи, вводится функция $eval: State \times Trace \to \mathcal{P}(State) \cup \{\lightning\}$, которая принимает на входе в качестве параметров исходное состояние и след и возвращает множество состояний, полученных при выполнении действий следа. Если след некорректный или завершается командой $fault$, то множество состояний пустое или $\{\lightning\}$ соответственно. Следовательно, $\llbracket P \rrbracket (s) = \{\tau \in A(P) \, | \, eval(s,\tau) \neq \emptyset \}$.
\begin{figure}
\begin{flalign*}
&A'(c)t = \{(\_,t,c)\} \\ 
&A'(C_1;C_2)t = \{\tau_1\tau_2 \,| \, \tau_1 \in A'(C_1)t \land \tau_2 \in A'(C_2)t \}\\
&A'(if \, (b) \, then \, C_1 \, else \, C_2)t =  \{(\_,t,assume(b))\tau_1 \, | \, \tau_1 \in A'(C_1)t \} \, \cup \\
& \{ (\_, t, assume(\neg b))\tau_2 \, | \, \tau_2 \in A'(C_2)t\}
&A'(while \, (b) \, do \, C)t = \{ ((\_,t,assume(b))(A'(C)t))^*(\_,t,assume(\neg b)) \} \\
&A'(x := o.f(e))t = \\ 
&\{ (\_,t, assume(e =n))(\_,t, call \, o.f(n))(\_,t,ret(n') \, o.f)(\_,t,x:=n') \, | \, n, n' \in \mathbb{Z}\} \, \cup \\
&\{(\_,t,assume(e=n))(_,t,call \, o.f(n))(\_,t,aborted) \, | \, n \in \mathbb{Z} \} \\
&A'(x:=atomic\{C\})t = \{ (\_,t,txbegin)(\_,t,aborted)(\_,t,x:= aborted) \} \, \cup \\ 
&\{(\_,t,txbegin)(\_,t,OK)\tau(\_,t,txcommit)(\_,t,r)(\_,t,x:= r) \, | \, \tau \in A'(C)t \, \land \, \\
&(\_,t,aborted) \notin \tau \, \land \, (r = committed \lor r = aborted) \} \, \cup \\ 
&\{(\_,t,txbegin)(\_,t,OK)\tau(\_,t,aborted)(\_,t,x:= aborted) \, | \, \tau(\_,t,aborted)\tau' \in A'(C)t \, \land \, \\
&(\_,t,aborted) \notin \tau\}\\
&A'(C_1 \parallel \ldots \parallel C_m) = \\
&prefix(\bigcup \{ interleave(\tau_1,\ldots, \tau_m) \, | \, \forall t \, 1 \leq t \leq m \implies \tau_t \in A'(C_t)t \})\\
&A(P) = A'(P) \cap Trace
\end{flalign*}
\caption{Определение множества $A(P)$}
\label{fig:actions}
\end{figure}

Определим множество $A(P)$. Функция $A'(P)$ на рисунке ~\ref{fig:actions} ставит в соответствие командам и программам множество действий, которое они могут исполнить. $A'(P)$ может содержать последовательность действий, которая не является следом программы. Поэтому множество $A(P)$ получаем пересечением множеств $A'(P)$ и $Trace$. $A'(C)t$ --- множество последовательностей действий, полученных при выполнении команды $C$ потоком $t$. Для построения множества $A'(P)$, строим множество чередованием последовательностей действий потоков программы. $A'(P)$ --- множество префиксов последовательностей действий, полученных на предыдущем шаге.

Далее подробнее рассмотрим рисунок ~\ref{fig:actions}. $A'(c)t$ возвращает в качестве результата множество, состоящее из действия примитивной команды $c$. $A'(C_1;C_2)t$ соединяет все возможные действия последовательностей, соответствующих $C_1$ и $C_2$. Оценка условий в операторах $if$ и $while$ осуществляется посредством примитивной команды $assume \in LPcomm_t$. Команда $assume(b)$ не выполняет ни каких действий, если $b$ ($b$ --- выражение логического типа над локальными переменными потока $t$) истинно, иначе останавливает вычисления. Таким образом, нужная ветка в операторе $if$ выбирается с помощью действия $assume$. Все возможные итерации цикла $while$ определены с помощью оператора Клини $^*$.

Множество последовательностей действий вызова метода объекта транзакционной памяти включает последовательности, в которых метод был выполнен успешно, и в результате выполнения которого транзакция была прервана. Множество последовательностей действий выполнения атомарного блока $x := atomic\{C\}$ содержит последовательности, в которых команда $C$ прервана во время выполнения, и в которых $C$ выполняется до завершения.

Рассмотрим семантику примитивных команд $c \in PComm - \{fault\}$. Функция $\llbracket c \rrbracket$ определяет, как состояние программы меняется после выполнения команды $c$. Семантика команды $c \in LPcomm_t$ задана функцией $\llbracket c \rrbracket: (LVar_t \to \mathbb{Z}) \to \mathcal{P}(LVar_t \to \mathbb{Z})$. Семантика команды $c \in GPcomm_t$ задана функцией $\llbracket c \rrbracket: ((LVar_t \uplus GVar) \to \mathbb{Z}) \to \mathcal{P}((LVar_t \uplus GVar)  \to \mathbb{Z})$. Функция $c$ --- недетерминированная.

Функция $q$ ставит в соответствие переменной, к которой у команды $c$ есть доступ, её значение. Рассмотрим семантику примитивной команды присваивания:
$$\llbracket x:=g \rrbracket(q) = \{ q[x \mapsto q(g) ] \}.$$ Значения функции $q[x \mapsto q(g) ]$ совпадают со значениями $q$ за исключением значения переменной $x$, которая принимает значение $q(g)$.

\counterwithout{equation}{chapter}
Приведем семантику команды $assume$:
\begin{equation}
  \llbracket assume(x=n)\rrbracket(q)=\begin{cases}
    \{q\}, & \text{if $q(x)=n$};\\
    \emptyset, & \text{otherwise}.
  \end{cases}
\end{equation}
Для того, чтобы определить функцию $\llbracket c \rrbracket$ для состояния программы, условимся, что значения переменных, к которым у команды $c$ нет доступа, остаются без изменений. Если $c$ завершается с ошибкой, то в качестве результата возвращается $\lightning$. Например, если $c \in LPcomm_t$, тогда: $$\llbracket c \rrbracket (s) = \{s |_{LVar\backslash LVar_t} \uplus \; q  \;| \; q \in \llbracket c \rrbracket (s |_{LVar_t}) \},$$ $$\llbracket fault \rrbracket (s) = \lightning.$$

Рассмотрим функцию оценки корректности следа. Используя семантику примитивных команд, определим корректность одного действия при состоянии программы $s$:
$$eval: State \times Action \to \mathcal{P}(State) \cup \{ \lightning\} $$
$$eval(s,(\_,t,c)) = \llbracket c\rrbracket (s);$$
$$eval(s,\psi) = \{s\}.$$
Далее определим функцию $eval$ для следа:
$$eval: State \times Trace \to \mathcal{P}(State) \cup \{ \lightning\} $$
\begin{equation}
  eval(s,\tau)=\begin{cases}
    \emptyset, & \text{if $\tau = \tau'\varphi \land eval(s, \tau') = \emptyset$};\\
    evalna(s, \tau |_{\neg abortact}), & \text{otherwise},
  \end{cases}
\end{equation}

\begin{equation}
     evalna(s,\tau)=\begin{cases}
    \{s\}, & \text{if $\tau =  \varepsilon$};\\ 
     \{s'' \in eval(s', \varphi) \, | \, s' \in  evalna(s, \tau') \}, & \text{if $\tau = \tau'\varphi$}.
   \end{cases}
  \end{equation}

$\tau |_{\neg abortact}$ --- след, полученный из следа $\tau$ удалением всех действий внутри прерванных транзакций. Множество состояний, полученное в результате анализа следа $\tau$ при состоянии программы $s$, вычисляется с помощью функции $evalna(s, \tau)$. Так как в данной модели вычисления после прерывания выполнения транзакций значения переменных принимают свои прежние значения, то функция $evalna(s, \tau)$ игнорирует действия внутри прерванных транзакций. Однако, последовательность действия внутри прерванных транзакций может быть некорректной. Поэтому функция $eval(s,\tau)$ рекурсивно проверяет каждый префикс следа $\tau$.

Благодаря функции $eval$ множество $\llbracket P \rrbracket(s)$ будет содержать только корректные следы выполнения программы.   

\chapter{Результаты} 

\begin{theorem} $\mathcal{T}_C$ и $\mathcal{T}_A$ --- конкретная и абстрактная транзакционная память соответственно, тогда :
\begin{enumerate}[label=(\roman*)]
\item Если $\mathcal{T}_A$ удовлетворяет 1 и 2 свойствам замкнутости, тогда $\mathcal{T}_C \sqsubseteq_{tms} \mathcal{T}_A \implies \mathcal{T}_C \preceq \mathcal{T}_A$.
\item Если $\mathcal{T}_A$ удовлетворяет 3 и 4 свойствам замкнутости, тогда $\mathcal{T}_C \implies \mathcal{T}_A \sqsubseteq_{tms} \mathcal{T}_C \preceq \mathcal{T}_A$.
\end{enumerate}

\end{theorem}
 
\section{Доказательство теоремы 1 (ii) (Необходимость)}
\begin{lemma}
Пусть $\mathcal{T}_C$ и $\mathcal{T}_A$ --- конкретная и абстрактная транзакционная память такие, что $\mathcal{T}_C \preceq \mathcal{T}_A$ и $\mathcal{T}_A$ удовлетворяет 3 и 4 свойствам замкнутости. Тогда $\forall H \in \mathcal{T}_C$ $\exists H^c \in comp(H |_{\neg live})$, $S \in \mathcal{T}_A$: $H^c|_{com} \, \sqsubseteq_{op} S$.
\end{lemma}
\begin{myproof} Выберем целое значение $u \neq 1$, которого нет в $H$. Введем следующие обозначения:
\begin{itemize}
\item[--] $m$ --- наибольший идентификатор потока, встречающийся в $H$. 
\item[--] $k^t$ --- число транзакций потока $t$ в $H$, то есть число $(\_,t,txbegin)$ действий в $H$. 
\item[--] Разделим $H|_t$ на $k^t$ подпоследовательностей: $H|_t$ = $H^t_{1} \ldots H^t_{k^t}$, где $H^t_i$ состоит из действий $i$ транзакции потока $t$, $H^t_i(1)$ = $(\_,t, txbegin)$.
\item[--] $c^t_i$ --- результат $i$ транзакции потока $t$, то есть $c^t_i = committed$ или $c^t_i = aborted$. Если транзакция не завершена, то значение $c^t_i$ не определено.
\item[--] $q^t_i$ --- число $call$ действий в $H^t_i$.
\item[--] $(\_,t, call \, o^t_{i,j}.f^t_{i,j}(n^t_{i,j}))$ --- $j$ $call$ действие в $H^t_i$. 
\item[--] $(\_,t, ret(r^t_{i,j}) \, o^t_{i,j}.f^t_{i,j})$ --- $j$ $ret$ действие в $H^t_i$. Если запрос $(\_,t, call \, o^t_{i,j}.f^t_{i,j}(n^t_{i,j}))$ завершается прерыванием транзакции, тогда $r^t_{i,j}$ = $aborted$. Если нет ответа на запрос, то есть транзакция действующая и $(\_,t, call \, o^t_{i,j}.f^t_{i,j}(n^t_{i,j}))$ --- последнее действие, тогда $r^t_{i,j}$ = $u$.
\item[--] $lasttx(t, i, t')$ --- число завершенных транзакций потока $t'$ в $H$ до начала $i$ транзакции потока $t$, то есть число $(\_,t', committed)$ и $(\_,t', aborted)$ действий предшествующих $H^t_{i}(1)$ = $(\_,t,txbegin)$ действию.
\end{itemize}
\begin{figure}
\begin{flalign*}
 GP^t_i  &= z^t_{i,1} := g^1_{lasttx(t,i,1)}; if \left(z^t_{i,1} \neq 1 \right) then \, fault; \\
 &\mathrel{\phantom{=}} \ldots \\ 
 &\mathrel{\phantom{=}} z^t_{i,m} := g^m_{lasttx(t,i,m)}; if \left(z^t_{i,m} \neq 1 \right) then \, fault
\end{flalign*}
\begin{itemize}
\item[--] Если $H^t_{i}$ --- зафиксированная транзакция или прерванная и видимая транзакция, тогда
\begin{alignat}{2}
     CP^t_i =&\quad \omega^t_{i} := &\; atomic\{&y^t_{i,1} := o^t_{i,1}.f^t_{i,1}(n^t_{i,1}); \; if \left (y^t_{i,1} \neq r^t_{i,1}\right) then \; fault; \nonumber \\
         &           &&\ldots \nonumber \\
         &           &&y^t_{i,q^t_i} := o^t_{i,q^t_i}.f^t_{i,q^t_i}(n^t_{i,q^t_i}); \; if \left (y^t_{i,q^t_i} \neq r^t_{i,q^t_i}\right) then \; fault\} \nonumber \\
         &\quad \mathrlap{if \left(\omega^t_{i} \neq c^t_{i} \right) then \; fault \; else \; g^t_{i} := 1} \nonumber
\end{alignat}
\item[--] Если $H^t_{i}$ --- действующая транзакция или прерванная и не видимая транзакция, тогда
\begin{alignat}{2}
     CP^t_i =&\quad \omega^t_{i} := &\; atomic\{&y^t_{i,1} := o^t_{i,1}.f^t_{i,1}(n^t_{i,1}); \nonumber \\
         &           &&\ldots \nonumber \\
         &           &&y^t_{i,q^t_i} := o^t_{i,q^t_i}.f^t_{i,q^t_i}(n^t_{i,q^t_i}); \nonumber \\
         &           &&fault \} \nonumber
\end{alignat}
\item[--] Если $H^t_{i}$ --- ожидающая фиксации транзакция, тогда 
\begin{alignat}{2}
     CP^t_i =&\quad \omega^t_{i} := &\; atomic\{&y^t_{i,1} := o^t_{i,1}.f^t_{i,1}(n^t_{i,1}); \; if \left (y^t_{i,1} \neq r^t_{i,1}\right) then \; fault; \nonumber \\
         &           &&\ldots \nonumber \\
         &           &&y^t_{i,q^t_i} := o^t_{i,q^t_i}.f^t_{i,q^t_i}(n^t_{i,q^t_i}); \; if \left (y^t_{i,q^t_i} \neq r^t_{i,q^t_i}\right) then \; fault\} \nonumber
\end{alignat}
\end{itemize}
\caption{Построение $GP^t_i$ и $CP^t_i$ команд}
\label{fig:commands}
\end{figure}
Для каждого потока $t$ = $1..m$ построим последовательность команд $$C^t_H = GP^t_1;CP^t_1;GP^t_2;CP^t_2;\ldots;GP^t_{k^t};CP^t_{k^t},$$ где $GP^t_i$ и $CP^t_i$ определены на рисунке ~\ref{fig:commands}.
Переменные $g^t_i$ --- глобальные, все остальные переменные --- локальные. Переменная $g^t_i$ используется для мониторинга порядка выполнения транзакций. Значение $g^t_i$ изменяется только потоком $t$ и используется для оповещения о завершении $i$ транзакции потока $t$. Переменная $z^t_{i,t'}$ используется для записи завершения $lasttx(t, i, t')$ транзакции потока $t'$, предшествующей начало $i$ транзакции потока $t$. Так как $lasttx(t, i, t')$ может равняться нулю, введём фиктивную переменную $g^t_0$ для каждого потока $t$. Переменная $\omega^t_i$ хранит информацию о статусе завершения $i$ транзакции потока $t$ (committed или aborted). Переменная $y^t_{i,j}$ записывает результат $j$ вызова метода объекта в $i$ транзакции потока $t$. 

Команда $GP^t_i;CP^t_i$ начинается с чтения сигналов ($g^t_{lasttx(t,i,t')}$) последней транзакции каждого потока $t'$, завершённой до начала $i$ транзакции потока $t$. Далее выполняется атомарный блок, в котором вызывается последовательность методов объектов транзакцией $H^t_i$. После завершения атомарного блока команда объявляет завершение транзакции. Определим программу $P_H$ следующим образом: $$P_H = C^1_H \; \parallel \ldots \parallel C^m_H.$$

Далее построим след $\tau$ программы $P_H$. Для начала построим $\tau^t$ для каждой последовательной команды $C^t_H$. Рассмотрим множество следов $A(C^t_H)t$ команды $C^t_H$, и пусть $\tau^t \in A(C^t_H)t$ --- максимальный след без $fault$ команды такой, что $H|_t$ = $history(\tau^t)$. След $\tau^t$ существует в связи с конструкцией $C^t_H$ и определением множества следов последовательной команды (рисунок \ref{fig:actions}). Во множестве $A(C^t_H)t$ существует след для каждого возможного параметра, результата вызова метода объекта и атомарного блока в $C^t_H$. В частности, $A(C^t)$ содержит след, в котором параметры, результат вызова методов объектов и атомарного блока такие же, как и в $H|_t$. Далее разделим каждый след $\tau^t$ на $|H|_t|$ подпоследовательностей: $$\tau^t = \tau^t_1\ldots\tau^t_{|H|_t|}.$$ Для каждого потока $i$ = $1..|H|_t|$ существует одно действие интерфейса $\psi^t_i$ в $\tau^t_i$, и выполняются условия, изображенные на рисунке \ref{fig:subtraces}. Это определяет след $\tau^t_i$ единственным образом и гарантирует, что, если след $\tau^t_i$ заканчивается $\psi^t_i = (\_,t,txbegin)$, то он содержит все действия, которые используются для чтения сигнализирующих глобальных переменных, предшествующих действию $\psi^t_i$ в $\tau^t$. Желаемый след строится с помощью чередования подпоследовательностей следов $\tau^1,\ldots,\tau^m$ согласно порядку, обусловленному историей $H$. Формально $$\tau = \tau^{t_1}_{j_1} \ldots \tau^{t_{|H|}}_{j_{|H|}},$$ где $H(i)$ = $(\_, t_i, \_)$ и $j_i$ = $|(H \downharpoonleft_i)|_{t_i}|.$ По построения $history(\tau)$ = $H$.
\begin{figure}
\begin{align*}
  \tau^t_i=\begin{cases}
    \_\psi^t_i, & \psi^t_i \in \{(\_,t,txbegin), (\_,t,call \; o.f(n)), (\_,t, txcommit)\};\\
    \psi^t_i, & \psi^t_i = (\_,t, OK); \\
    \psi^t_i(\_,t,y^t_{i,\_} := n), & \psi^t_i = (\_,t, ret(n) \; o.f) \land txof(\psi^t_i, \tau^t) \in live(\tau^t); \\
    \mathrlap{\psi^t_i(\_,t,y^t_{i,\_} := n)(\_,t,assume(y^t_{i,\_} = r^t_{i,\_})),}\\
                                    & \psi^t_i = (\_,t, ret(n) \; o.f) \land txof(\psi^t_i, \tau^t) \notin live(\tau^t); \\
    \mathrlap{\psi^t_i(\_,t,\omega_i := c^t_i)(\_,t,assume(\omega_i = c^t_i))(\_,t,g^t_i := 1),}\\
                                    & \psi^t_i \in \{(\_,t,committed, (\_,t,aborted))\}.       
  \end{cases}
\end{align*}
\caption{Построение $\tau^t_i$}
\label{fig:subtraces}
\end{figure}
Так как $\tau^t \in A(C^t_H)t$, то $\tau \in A(P_H)t$. Пусть $s$ --- состояние программы, в которой все локальные переменные инициализированы целым числом $u$, а глобальные переменные $g^t_i = 0$ при $i \neq 0$ и $g^t_0 = 1$. $eval(s,\tau) \neq \emptyset$ по построению $\tau$. Так как $history(\tau) = H \in \mathcal{T}_C$, то $\tau \in \llbracket P_H \rrbracket(s,\mathcal{T}_C)$. Так как $\tau \in \llbracket P_H \rrbracket(s,\mathcal{T}_C)$ и $\mathcal{T}_C \preceq \mathcal{T}_A$, то по определению \ref{def1} % изменить ссылку на опр 
существует след $\tau' \in \llbracket P_H \rrbracket(s,\mathcal{T}_A)$ такой, что $\tau'|_{\neg trans}$ = $\tau|_{\neg trans}$ и $S_1 = history(\tau') \in \mathcal{T}_A$.

Пусть $T$ и $T'$ --- $i$ транзакции потока $t$ в $\tau|_t$ и $\tau'|_t$ соответственно. Так как $\tau'|_{\neg trans}$ = $\tau|_{\neg trans}$, то либо транзакции $T$ и $T'$ запускается одинаковыми командами, либо $T'$ не существует. Проанализируем зависимость между этими транзакциями, основываясь на конструкции команды $C^t_H$ (рисунок \ref{fig:commands}):
\begin{itemize}
\item[--] Если транзакция $T$ завершена, тогда транзакция $T'$ тоже завершена, так как после завершения транзакции переменной $g^t_i$ присваивается новое значение и $\tau'|_{\neg trans}$ = $\tau|_{\neg trans}$. Завершённая транзакция $T$ --- зафиксированная тогда и только тогда, когда $T'$ --- зафиксированная. В данном случае проверки, выполненные внутри соответствующих атомарных блоков, доказывают, что возвращаемые результаты транзакционных действий внутри $T$ и $T'$ совпадают.
% может заменить слово доказывает на утверждает ?
\item[--] Если транзакция $T$ --- действующая, тогда вызов команды $fault$ до завершения атомарного блока доказывает, что транзакция $T'$ может быть действующей, прерванной или не существовать. 
\item[--] Если транзакция $T$ ожидает фиксацию, тогда у транзакции $T'$ может быть любой статус, или она может не существовать. Однако, если $T$  --- видимая, тогда проверки внутри атомарного блока доказывают, что результаты транзакционных действий внутри $T$ и $T'$ совпадают.
\end{itemize}

Пусть $H_1 = (H|_{\neg live})|_{\neg abortedtx}$ и $S_2 = (S_1|_{\neg live})|_{\neg abortedtx}$. Так как $S_1 \in \mathcal{T}_A$ и $\mathcal{T}_A$ замкнута относительно операции удаления действующих и прерванных транзакций, то $S_2 \in \mathcal{T}_A$. Пусть $p'_t$ и $p''_t$ --- индексы последних $txcommit$ или $committed$ действий в $H_1|_t$ и $S_2|_t$ соответственно. В случае отсутствия этих действий, индексы равны 0. Пусть $p_t=min(p'_t,p''_t)$. Из приведенного анализа следует, что $\forall \; t \; (H_1|_t)\downharpoonleft_{p_t} \equiv (S_2|_t)\downharpoonleft_{p_t}$. Пусть $S_3$ --- история, полученная из $S_2$ переименованием идентификаторов действий таким образом, что $S_3 \equiv S_2$, $\forall \; t \; (H_1|_t)\downharpoonleft_{p_t} = (S_3|_t)\downharpoonleft_{p_t}$, и все действия в $S_3$, которые не принадлежат $(S_2|_t)\downharpoonleft_{p_t} \; \forall \; t$, имеют идентификаторы, которые не встречаются в $H$. Так как $S_2 \in \mathcal{T}_A$ и $\mathcal{T}_A$ замкнута относительно операции переименования идентификаторов, то $S_3 \in \mathcal{T}_A$.

Так как $S_3 \in \mathcal{T}_A$ и $\mathcal{T}_A$ --- замкнута относительно операции завершения транзакций, ожидающих фиксации, получаем, что существует история $S_4 \in nicomp(S_3) \cap \mathcal{T}_A$. Пусть $S'_3$ --- подпоследовательность $S_4$, которая содержит только $committed$ или $aborted$ действия, которых нет в $S_3$. % т.е. эти действия - завершение транз
Идентификаторы действий в $S'_3$ не встречаются в $H$. Пусть $S''_3$ --- подпоследовательность $committed$ действий в $S_3$, которых нет в $H_1$. Построим требуемую историю $H^c$ с помощью прерывания всех ожидающих фиксации транзакций истории $(H|_{\neg live})S''_3S'_3$. Пусть $H^c = (H|_{\neg live})S''_3S'_3H_a$, где $H_a$ состоит из действий $(\_, t, aborted)$ для каждого потока $t$, который завершается транзакцией, ожидающей фиксации, в $(H|_{\neg live})S''_3S'_3$. У этих действий есть уникальные идентификаторы, которые не появляются в $H$. $H^c \in comp(H|_{\neg live})$ по следующим причинам: 
\begin{enumerate}[label=(\roman*)]
\item $S''_3$ завершает транзакции, зафиксированные в $S_1$, но ожидающие фиксацию в $H$.  
\item $S'_3$ завершает транзакции, ожидающие фиксацию в $H$ и $S_1$.
\item $H_a$ прерывает транзакции, ожидающие фиксацию в $H$, которые могут быть действующими, прерванными или не существовать в $S_1$.
\end{enumerate}

Пусть $S = S_4|_{com}$. $S \in \mathcal{T}_A$, так как $S_4 \in \mathcal{T}_A$ содержит только завершенные транзакции, и транзакционная память $\mathcal{T}_A$ замкнута относительно удаления действующих и прерванных транзакций. Докажем, что $H^c|_{com} \sqsubseteq_{op} S$. Для начала покажем, что $\forall \; t \; (H^c|_t)|_{com} = S|_t$, рассмотрев следующие случаи:
\begin{itemize}
\item[--] $H|_t$ не содержит транзакций, ожидающих фиксацию. Тогда $p'_t = p''_t$, $H_1|_t = S_3|_t$ и $S'_3 = S''_3 = H_a = \varepsilon$. Следовательно, $$(H^c|_t)|_{com} = (H_1|_t)|_{com} = (S_3|_t)|_{com} = (S_4|_t)|_{com} = S|_t.$$
\item[--] $H|_t$ завершается транзакцией, ожидающей фиксацию, и $(S''_3S'_3H_a)|_t = S''_3|_t = (\_,t,committed)$. Тогда $H_1|_t = (H_1|_t)\downharpoonleft_{p_t}$ и $S_3|_t = ((S_3|_t)\downharpoonleft_{p_t})(S''_3|_t)$. Следовательно, 
\begin{align*}
(H^c|_t)|_{com} = ((H_1|_t)(S''_3|_t))|_{com} = (((H_1|_t)\downharpoonleft_{p_t})(S''_3|_t))|_{com} = \\
(((S_3|_t)\downharpoonleft_{p_t})(S''_3|_t))|_{com} = (S_3|_t)|_{com} = (S_4|_t))|_{com} = S|_t.
\end{align*}
\item[--] $H|_t$ завершается транзакцией, ожидающей фиксацию, и $(S''_3S'_3H_a)|_t = S'_3|_t$. Тогда $H_1|_t = S_3|_t$, так как $p'_t = p''_t$. Следовательно, 
\begin{align*}
(H^c|_t)|_{com} = ((H_1|_t)(S'_3|_t))|_{com} = ((S_3|_t)(S'_3|_t))|_{com} = (S_4|_t)|_{com} = S|_t.
\end{align*}
\item[--] $H|_t$ завершается транзакцией, ожидающей фиксацию, и $(S''_3S'_3H_a)|_t$ = $H_a|_t$ = $(\_, t, aborted)$. Тогда $((H_1|_t)(H_a|_t))|_{com} = ((H_1|_t)\downharpoonleft_{p_t})|_{com}$ и $S_3|_t = (S_3|_t)\downharpoonleft_{p_t}$. Следовательно,
\begin{align*}
(H^c|_t)|_{com} = ((H_1|_t)(H_a|_t))|_{com} = ((H_1|_t)\downharpoonleft_{p_t})|_{com} =\\
((S_3|_t)\downharpoonleft_{p_t})|_{com} = (S_3|_t)|_{com} = (S_4|_t)|_{com} = S|_t. 
\end{align*}
\end{itemize}

Эти рассуждения доказывают, что $\forall \; t \; (H^c|_t)|_{com} = S|_t$. Для каждой завершённой транзакции $T$ в $\tau$ значение $g^t_i = 1$, и значение этой переменной читается до начала транзакции $T'$, которая запускается после завершения $T$. Следовательно транзакция в $\tau'$, соответствующая $T$, завершается до начала транзакции в $\tau'$, соответствующей $T'$. Следовательно порядок выполнения транзакций в $H^c$ сохраняется в $S$, откуда следует, что $H^c|_{com} \sqsubseteq_{op} S$. 
\end{myproof}

\section{Доказательство теоремы 1 (i) (Достаточность)}
 

\Conc




% Печать списка литературы (библиографии)
\printbibliography[heading=bibintoc%
    %,title=Библиография % если хочется это слово
]
% Файл со списком литературы: biblio.bib
% Подробно по оформлению библиографии:
% см. документацию к пакету biblatex-gost
% http://ctan.mirrorcatalogs.com/macros/latex/exptl/biblatex-contrib/biblatex-gost/doc/biblatex-gost.pdf
% и огромное количество примеров там же:
% http://mirror.macomnet.net/pub/CTAN/macros/latex/contrib/biblatex-contrib/biblatex-gost/doc/biblatex-gost-examples.pdf

\end{document}
