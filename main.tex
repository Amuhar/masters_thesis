% В этом файле следует писать текст работы, разбивая его на
% разделы (section), подразделы (subsection) и, если нужно,
% главы (chapter).

% Предварительно следует указать необходимую информацию
% в файле SETUP.tex

\input{preamble.tex}

\begin{document}

\Intro
Транзакционная память упрощает процесс написания многопоточных приложений, позволяя исполнять блоки кода как атомарные транзакции. Команды, относящиеся к данным блокам, выполняются за единицу времени, и промежуточные результаты исполнения не доступны для других блоков. В данном случае изменения доступны только после фиксации транзакции. 

Рассмотрим вариант использования транзакционной памяти, изображенный на рисунке \ref{fig:tm}. В данном примере атомарный блок используется для управления транзакциоными объектами $X$, $Y$, $Z$. Блок будет перезапускаться до тех пор, пока изменения не будут зафиксированы.

Одним из важнейших вопросов для реализации транзакционной памяти является её корректность. Общепринято для достижения данной цели использовать условие согласованности, которое накладывает ограничения на взаимодействие программы и транзакционной памяти. Основная сложность формулирования данного условия заключается в необходимости гарантировать корректность состояния объектов транзакционной памяти, к которым осуществляется обращение в действующих транзакциях. Действующими мы будем называть транзакции, находящиеся в процессе выполнения команд. Так как действующие транзакции могут быть прерваны транзакционной памятью в любой момент, и все изменения будут сброшены, можно предположить, что нет необходимости беспокоиться о состоянии объектов. Однако в условиях транзакционной памяти это может привести к множеству проблем.

Приведём пример, изложенный в работе \cite{Guerraoui07opacity:a}. Рассмотрим два объекта транзакционной памяти $x$ и $y$. Предположим, что значение $y$ равно $x^2$ и $x \geq 2$. Исходные значения $x$ и $y$ равны четырём и шестнадцати соответственно. Пусть транзакция $T_1$ исполняет следующий атомарный блок: $$ result := atomic \{ x := 2; \; y := 4; \}.$$ Если транзакция $T_2$ прочтёт старое значение $x$ равное четырём и новое значение $y$ равное четырём и после этого вычислит значение $1 / (x - y)$, то в программе возникнет ошибка из-за деления на ноль.

\counterwithout{figure}{chapter}
\begin{figure}[t]
\begin{align*}
&result := abort;\\
&while \left (result == abort \right) \{ \\
& \qquad result := atomic \{ \\
& \qquad \qquad x := X.read(); \\
& \qquad \qquad y := Y.read(); \\ 
& \qquad \qquad z := 42 / (x - y); \\
& \qquad \qquad Z.write(z); \\
& \qquad \} \\
&\}
\end{align*}
\caption{Использование транзакционной памяти}
\label{fig:tm}
\end{figure}
Вопрос о выборе условия согласованности транзакционной памяти далёк от тривиального. Идеальное условие должно быть достаточно слабым для того, чтобы обеспечить гибкость реализации транзакционной памяти, и достаточно сильным для того, чтобы удовлетворить интуитивным ожиданиям программиста и запретить нежелательные сценарии, такие как описано выше. Уточнение наблюдений % может следует написать просто уточнение
позволяет формально описать ожидания программиста и, следовательно, оценить условие согласованности. Рассмотрим две реализации транзакционной памяти: конкретную, такую как эффективная транзакционная память, и абстрактную, такую как транзакционная память, выполняющая каждую транзакцию атомарно. Конкретная транзакционная память уточняет абстрактную транзакционную память в условиях данного языка программирования, если каждое поведение программы при взаимодействии с конкретной транзакционной памятью можно наблюдать и при взаимодействии с абстрактной. Благодаря уточнению программист может рассуждать о поведении программы (например, о сохранности инварианта $x \neq y$), используя семантику, формализованную абстрактной транзакционной памятью. Из отношения уточнения следует, что все выводы справедливы для случая, когда программа взаимодействует с конкретной транзакционной памятью (например, безопасность деления). Далее взаимодействие программы с транзакционной памятью будем называть историей.    

В данной работе будет рассмотрено условие согласованности транзакционной памяти, представленное в работе \cite{tms_article}, под названием transactional memory specification (TMS). Нас будет интересовать $TMS$ отношение между конкретной и абстрактной реализациями транзакционной памяти. 
% Конкретная транзакционная память находится в $TMS$ отношении с абстрактной транзакционной памятью, если выполняются следующие условия:
% \begin{itemize}
% \item[--] Для проекции $H|_{com}$ истории конкетной транзакционной памяти $H$ на зафиксированные транзакции существует история абстрактной транзакционной памяти $S$ такая, что действия каждого потока $t$ истории $S$ совпадают с действиями потока $t$ истории $H|_{com}$, и порядок следования не пересекающихся транзакций сохраняется.
% \item[--] Каждый ответ конкретной транзакционной памяти в действующей или прерванной транзакции, кроме действия прерывания транзакции, подтверждается отдельной историей абстрактной транзакционной памяти. 
% \end{itemize}
% Гибкость в выборе абстрактной истории позволяет выполнять необходимое количество оптимизаций в конкретной реализации транзакционной памяти. 
Нами будет рассмотрена теорема о равносильности $TMS$ отношения и уточнения абстрактной транзакционной памяти, удовлетворяющей определённым требованиям, конкретной транзакционной памятью. Благодаря этой теореме мы можем рассуждать о корректности транзакционной памяти в терминах отношения уточнения, которое формализует ожидания программиста относительно выполнения клиентской программы. Теорема сформулирована и доказана в работе \cite{tms_article}. Нами будет приведено более подробное доказательство данной теоремы и всех вспомогательных лемм. 

Важно отметить, что отношение уточнения зависит от выбора языка программирования. В связи с этим мы опишим синтаксис и семантику языка программирования, приведённого в работе \cite{tms_article}, на основе которого будем изучать условие согласованности транзакционной памяти. Мы расширим данный язык программирования введением команды явного прерывания транзакций, запрещённой в работе \cite{tms_article}, и докажем устойчивость доказательств к введению новой конструкции в язык программирования.

% Если typeOfWork в SETUP.tex задан как 2 или 3, то начинать
% надо не с section (раздел), а с главы (chapter)
\chapter{Синтаксис и семантика языка программирования}


\section{Синтаксис}
Рассмотрим язык программирования, в котором программа $P$ представляется в виде параллельной композиции потоков  $C_t,\, t \in ThreadId=\{1, \ldots, m \}$: $P = C_1 \parallel \ldots \parallel C_m$. У каждого потока $t \in Threads$ есть набор локальных переменных $LVar_t = \{x,y, \ldots \}$ и общий набор глобальных переменных $GVar = \{g, \ldots \}$. Все переменные целого типа. Обозначим  $Var = GVar \uplus \biguplus_{t = 1}^m LVar_{t}$ --- множество всех переменных программы. У потоков также есть доступ к транзакционной памяти, которая управляет фиксированным набором объектов $Obj = \{o, \ldots \}$. У каждого объекта есть множество методов, которые могут быть вызваны потоками. Предполагается, что каждый метод принимает на входе целое значение и возвращает в качестве результата целое значение. У всех объектов транзакционной памяти один и тот же набор методов $Method = \{f, \ldots \}$. Синтаксис команд $C$ рассматриваемого языка программирования стандартный. $C$ может иметь вид: $$ c \,|\, C;C \,|\, while \left (b\right) \, do \, C \,|\, if \left (b\right) then \, C\, else \, C \, | \, x := atomic \, \{ C \} \, | \, x := o.f(e), $$ где $b$ и $e$ обозначают логические и целые операции над локальными переменными. Синтаксис включает примитивную команду $c$ из множества $PComm$, последовательность команд, цикл, условный оператор, атомарный блок и вызов методов объектов. Примитивные команды исполняются атомарно. Множество $PComm$ включает присваивания значений локальным и глобальным переменным и специальную операцию fault, которая останавливает исполнение программы в ошибочном состоянии. Следовательно, fault вызывается при некорректных вычислениях, таких как деление на ноль.

Атомарный блок $x := atomic \, \{C\}$ исполняет $C$ как транзакцию, которую транзакционная память может зафиксировать или прервать. Решение системы ($aborted$ или $committed$) будет записано в локальную переменную $x$. 

В данный языке программирования введено ограничение доступа к переменным и объектам транзакционной памяти. Вызов методов объектов транзакционной памяти возможен только внутри транзакций, доступ к глобальным переменным осуществляется только вне транзакций. Локальные переменные доступны в обоих случаях, но потокам запрещен доступ к локальным переменным других потоков.

Для формального описания ограничения доступа примитивных команд к переменным, множество $PComm - \{fault\}$ разделяется на два подмножества: $\biguplus_{t=1}^m (LPcomm_t \uplus GPcomm_t)$. Команды из подмножества $LPcomm_t$ имеют доступ только к локальным переменным потока $t$ ($LVar_t$). У команд из подмножества $GPcomm_t$ есть доступ как к локальным переменным потока $t$, так и к глобальным переменным программы ($LVar_t \uplus GVar$). 

\section{Модель вычисления}
Прежде чем перейти к определению семантики данного языка программирования, введём основные термины. 

\begin{mydefinition}\label{def1} Пусть $ActionId$ --- множество идентификаторов действий. Действие интерфейса $\psi$ транзакционной памяти ($TM$) может иметь одно из следующих представлений:\\

\begin{tabular}{llr}
\hline
Запрос  & Ответ \\
\hline
$(a, t, txbegin)$ & $(a, t, OK)$ & $(a, t, aborted)$     \\
$(a, t, txcommit)$ & $(a, t, committed)$ & $(a, t, aborted)$ \\
$(a, t, call \, o.f(n))$ & $(a, t, ret (n') \, o.f)$ & $(a, t, aborted)$ \\
\hline
\end{tabular}\\
\\
где $a \in ActionId, t \in ThreadId, o \in Obj, f \in Method$ и $n,n' \in \mathbb{Z}$. Примитивное действие $\chi$ обозначается как $(a, t, c)$, где $c \in PComm$. Все остальные действия обозначим $\varphi$.
\end{mydefinition}
Посредством действий интерфейса программа взаимодействует с транзакционной памятью.
Действие $txbegin$ генерируется после входа в атомарный блок, а действие $txcommit$ при попытке фиксации изменений после выхода из атомарного блока. Действия $call$ и $ret$ обозначают вызов метода транзакционного объекта и результат вызова соответственно. $n$ и $n'$ - входной параметр метода и результат вызова соответственно. $TM$ может прервать транзакцию в ответ на запрос программы.

\begin{mydefinition}\label{def2} След $\tau$ --- конечная последовательность действий, удовлетворяющих следующим условиям:
\begin{enumerate}
  \item Каждое действие в $\tau$ обладает уникальным идентификатором: $if \, \tau = \tau_1 (\alpha_1,\_,\_) \tau_2 (\alpha_2,\_,\_) \tau_3 \, then \, \alpha_1 \neq \alpha_2$.   
  \item За командой $fault$ не следуют другие действия: если $\tau = \tau'\varphi$, тогда $\tau'$ не содержит $fault$ действие.
  \item Запросы и ответы верно сопоставлены.
  \item $\tau|_t$ для $\forall t$ не содержит запросы, следующие сразу за примитивными действиями.
  \item Действия, обозначающие начало и конец транзакции, верно сопоставлены: в проекции следа $\tau|_t$ для $\forall t$ на $txbegin, committed$ и $aborted$ действия для каждого $txbegin$ действия содержится $committed$ или $aborted$ действие.
  \item Действия $call$ и $ret$ встречаются только внутри транзакций: если $\tau|_t = \tau_1\psi\tau_2$ для $\forall t$, где $\psi$ --- $call$ или $ret$ действие, тогда $\tau_1 = \tau_1'\psi'\tau_1''$ для некоторого $\psi' = (\_,t,txbegin)$, и $\tau_1''$ не содержит $committed$ или $aborted$ действия.
  \item У команд в $\tau$ нет доступа к локальным переменным других потоков: если $(\_,t,c) \in \tau$, тогда $c \in LPcomm_t \uplus GPcomm_t \uplus \{ fault\}$.
  \item У команд в $\tau$ нет доступа к глобальным переменным внутри транзакций: если $\tau = \tau_1(\_,t,c)\tau_2$ для $c \in GPcomm_t$, тогда $\tau_1 \neq \tau_1'(\_,t,txbegin)\tau_1''$ при $\tau_1''$, не содержащем $committed$ или $aborted$ действия.
\end{enumerate}

\end{mydefinition}

Обозначим множество следов $Trace$. След, содержащий только действия интерфейса, называется историей. Транзакционная память $\mathcal{T}$ --- множество историй, замкнутых относительно операции переименования идентификатора и относительно префиксов историй.

Введём ряд обозначений. Пусть незначительные выражения обозначаются как \_; $i$ элемент следа $\tau$ --- $\tau(i)$; $\tau|_t$ --- проекция следа $\tau$ на действия вида $(\_,t,\_)$; $|\tau|$ --- длина следа; $\tau_1\tau_2$ --- конкатенация следов $\tau_1$, $\tau_2$; $\tau\downharpoonleft_i$ --- префикс следа $\tau$, содержащий $i$ действий. Пустую последовательность действий обозначим как $\varepsilon$.

\begin{mydefinition}\label{def3} Два следа $\tau$ и $\tau'$ эквиваленты относительно идентификаторов, $\tau \equiv \tau'$,если $|\tau| = |\tau'|$ и для каждого $i = 1..|\tau|$ действия $\tau(i)$ и $\tau'(i)$ могут отличаться только идентификаторами.
\end{mydefinition}

Транзакция T --- непустой след, содержащий действия, принадлежащие одному потоку, начинающийся с $txbegin$ действия и только последнее действие следа может быть $committed$ или $aborted$ действием. Рассмотрим статусы транзакций. Транзакция $T$ зафиксированная, если завершается $committed$ действием. Транзакция $T$ прерванная, если завершается $aborted$ действием. Транзакция $T$ ожидает фиксацию, если завершается $txcommit$ действием. Транзакция $T$ действующая во всех остальных случаях. Также транзакция считается завершенной, если она прерванная или зафиксированная. Транзакция видимая, если содержит $txcommit$ действие. След $\tau$ содержит транзакцию $T$, $T \in \tau$, если $\tau|_t = \tau_1T\tau_2$ для некоторого $t$, $\tau_1$ и $\tau_2$, при этом либо $T$ --- завершенная транзакция, либо $\tau_2$ пустой след. Обозначим $tx(\tau)$ --- множество всех транзакций, принадлежащих следу $\tau$. Множество зафиксированныхх, прерванных, ожидающих фиксации, действующих и видимых транзакций обозначим как $committed(\tau)$, $aborted(\tau)$, $pending(\tau)$, $live(\tau)$, $visible(\tau)$ соответственно. Обозначим транзакцию следа $\tau$, содержащую действие $\varphi$, как $txof(\varphi, \tau)$.

\section{Семантика}  
Для того, чтобы определить семантику данного языка программирования, определим множество следов исполнения программы. Состоянием программы $s$ будем называть значения всех переменных программы: $s \in State = Var \to \mathbb{Z} $. Семантика программы $P = C_1 \parallel \ldots \parallel C_m$ задана множеством следов $\llbracket P, \mathcal{T} \rrbracket (s) \subseteq Trace$, полученных при исполнении программы, взаимодействующей с транзакционной памятью $\mathcal{T}$ при исходном состоянии $s$. Чтобы определить это множество, для начала определим множество $\llbracket P \rrbracket (s) \subseteq Trace$ без ограничений взаимодействия с транзакционной памятью.

Для формального описания множества $\llbracket P \rrbracket (s)$, определим множество $A(P)$, состоящее из всех следов, которые могут быть исполнены. Например, если поток выполняет команду $x := 1;\; if \; (x = 1) \; than \; y := 1 \; else \; y := 2$, где $x, y$ --- локальные переменные, тогда $A(P)$ будет содержать след, в котором $y := 2$, вместо $y := 1$. Для того, чтобы отфильтровать подобные случаи, вводится функция $eval: State \times Trace \to \mathcal{P}(State) \cup \{\lightning\}$, которая принимает на входе в качестве параметров исходное состояние и след и возвращает множество состояний, полученных при выполнении действий следа. Если след некорректный или завершается командой $fault$, то множество состояний пустое или $\{\lightning\}$ соответственно. Следовательно, $\llbracket P \rrbracket (s) = \{\tau \in A(P) \, | \, eval(s,\tau) \neq \emptyset \}$.
\begin{figure}[t]
% \begin{flalign*}
\begin{alignat}{2}
&\mathrlap{A'(c)t = \{(\_,t,c)\}} \nonumber \\ 
&\mathrlap{A'(C_1;C_2)t = \{\tau_1\tau_2 \,| \, \tau_1 \in A'(C_1)t \land \tau_2 \in A'(C_2)t \}} \nonumber\\
&A'(if \, (b) \, then \, C_1 \, else \, C_2)t =  &\{(\_,t,assume(b))\tau_1 \, | \, \tau_1 \in A'(C_1)t \} \, \cup \nonumber \\
&& \{ (\_, t, assume(\neg b))\tau_2 \, | \, \tau_2 \in A'(C_2)t\} \nonumber \\
&\mathrlap{A'(while \, (b) \, do \, C)t = \{ ((\_,t,assume(b))(A'(C)t))^*(\_,t,assume(\neg b)) \}} \nonumber\\
&\mathrlap{A'(x := o.f(e))t =} \nonumber \\
&\mathrlap{\{ (\_,t, assume(e =n))(\_, t, call \, o.f(n))(\_,t,ret(n') \, o.f)(\_,t,x:=n') \, | \, n, n' \in \mathbb{Z}\} \, \cup} \nonumber \\
&\mathrlap{\{(\_,t,assume(e=n))(\_,t,call \, o.f(n))(\_,t,aborted) \, | \, n \in \mathbb{Z} \}} \nonumber \\
&\mathrlap{A'(x:=atomic\{C\})t = \{ (\_,t,txbegin)(\_,t,aborted)(\_,t,x:= aborted) \} \, \cup} \nonumber \\
&\mathrlap{\{(\_,t,txbegin)(\_,t,OK)\tau(\_,t,aborted)(\_,t,x:= aborted) \; | }  \nonumber \\
& \mathrlap{\tau(\_,t,aborted)\tau' \in A'(C)t \; \land \; (\_,t,aborted) \notin \tau\} \; \cup} \nonumber \\ 
& \mathrlap{\{(\_,t,txbegin)(\_,t,OK)\tau(\_,t,txcommit)(\_,t,r)(\_,t,x:= r) \; | \; \tau \in A'(C)t  \; \land } \nonumber \\
&\mathrlap{(\_,t,aborted) \notin \tau \, \land \, (r = committed \lor r = aborted) \}} \nonumber \\
& \mathrlap{A'(C_1 \parallel \ldots \parallel C_m) =} \nonumber \\ 
& \mathrlap{prefix(\bigcup \{ interleave(\tau_1,\ldots, \tau_m) \, | \, \forall t \, 1 \leq t \leq m \implies \tau_t \in A'(C_t)t \}) } \nonumber \\
& \mathrlap{A(P) = A'(P) \cap Trace} \nonumber
\end{alignat}
 \caption{Определение множества $A(P)$}
\label{fig:actions}
\end{figure}

Определим множество $A(P)$. Функция $A'(P)$ на рисунке ~\ref{fig:actions} ставит в соответствие командам и программам множество действий, которое они могут исполнить. $A'(P)$ может содержать последовательность действий, которая не является следом программы. Поэтому множество $A(P)$ получаем пересечением множеств $A'(P)$ и $Trace$. $A'(C)t$ --- множество последовательностей действий, полученных при выполнении команды $C$ потоком $t$. Для построения множества $A'(P)$ построим вспомогательное множество чередованием последовательностей действий потоков программы. $A'(P)$ --- множество префиксов последовательностей действий, полученных на предыдущем шаге.

Далее подробнее рассмотрим рисунок ~\ref{fig:actions}. $A'(c)t$ возвращает в качестве результата множество, состоящее из действия примитивной команды $c$. $A'(C_1;C_2)t$ соединяет все возможные действия последовательностей, соответствующих $C_1$ и $C_2$. Оценка условий в операторах $if$ и $while$ осуществляется посредством примитивной команды $assume \in LPcomm_t$. Команда $assume(b)$ не выполняет ни каких действий, если $b$ ($b$ --- выражение логического типа над локальными переменными потока $t$) истинно, иначе останавливает вычисления. Таким образом, нужная ветка в операторе $if$ выбирается с помощью действия $assume$. Все возможные итерации цикла $while$ определены с помощью оператора Клини $^*$.

Множество последовательностей действий вызова метода объекта транзакционной памяти включает последовательности, в которых метод был выполнен успешно, и в результате выполнения которого транзакция была прервана. Множество последовательностей действий выполнения атомарного блока $x := atomic\{C\}$ содержит последовательности, в которых команда $C$ прервана во время выполнения, и в которых $C$ выполняется до завершения.

Рассмотрим семантику примитивных команд $c \in PComm - \{fault\}$. Функция $\llbracket c \rrbracket$ определяет, как состояние программы меняется после выполнения команды $c$. Семантика команды $c \in LPcomm_t$ задана функцией $\llbracket c \rrbracket: (LVar_t \to \mathbb{Z}) \to \mathcal{P}(LVar_t \to \mathbb{Z})$. Семантика команды $c \in GPcomm_t$ задана функцией $\llbracket c \rrbracket: ((LVar_t \uplus GVar) \to \mathbb{Z}) \to \mathcal{P}((LVar_t \uplus GVar)  \to \mathbb{Z})$. Функция $c$ --- недетерминированная.

Функция $q$ ставит в соответствие переменной, к которой у команды $c$ есть доступ, её значение. Рассмотрим семантику примитивной команды присваивания:
$$\llbracket x:=g \rrbracket(q) = \{ q[x \mapsto q(g) ] \}.$$ Значения функции $q[x \mapsto q(g) ]$ совпадают со значениями $q$, за исключением значения переменной $x$, которая принимает значение $q(g)$.

\counterwithout{equation}{chapter}
Приведем семантику команды $assume$:
\begin{align*}
  \llbracket assume(x=n)\rrbracket(q)=\begin{cases}
    \{q\}, & \text{if $q(x)=n$};\\
    \emptyset, & \text{otherwise}.
  \end{cases}
\end{align*}
Для того, чтобы определить функцию $\llbracket c \rrbracket$ для состояния программы, условимся, что значения переменных, к которым у команды $c$ нет доступа, остаются без изменений. Если $c$ завершается с ошибкой, то в качестве результата возвращается $\lightning$. Например, если $c \in LPcomm_t$, тогда: $$\llbracket c \rrbracket (s) = \{s |_{LVar\backslash LVar_t} \uplus \; q  \;| \; q \in \llbracket c \rrbracket (s |_{LVar_t}) \},$$ $$\llbracket fault \rrbracket (s) = \lightning.$$

Рассмотрим функцию оценки корректности следа. Используя семантику примитивных команд, определим корректность одного действия при состоянии программы $s$:
$$eval: State \times Action \to \mathcal{P}(State) \cup \{ \lightning\} $$
$$eval(s,(\_,t,c)) = \llbracket c\rrbracket (s);$$
$$eval(s,\psi) = \{s\}.$$
Далее определим функцию $eval$ для следа:
$$eval: State \times Trace \to \mathcal{P}(State) \cup \{ \lightning\} $$
\begin{align*}
  eval(s,\tau)=\begin{cases}
    \emptyset, & \text{if $\tau = \tau'\varphi \land eval(s, \tau') = \emptyset$};\\
    evalna(s, \tau |_{\neg abortact}), & \text{otherwise},
  \end{cases}
\end{align*}

\begin{align*}
     evalna(s,\tau)=\begin{cases}
    \{s\}, & \text{if $\tau =  \varepsilon$};\\ 
     \{s'' \in eval(s', \varphi) \, | \, s' \in  evalna(s, \tau') \}, & \text{if $\tau = \tau'\varphi$}.
   \end{cases}
  \end{align*}

$\tau |_{\neg abortact}$ --- след, полученный из следа $\tau$ удалением всех действий внутри прерванных транзакций. Множество состояний, полученное в результате анализа следа $\tau$ при состоянии программы $s$, вычисляется с помощью функции $evalna(s, \tau)$. Так как в данной модели вычисления после прерывания выполнения транзакций значения переменных принимают свои прежние значения, то функция $evalna(s, \tau)$ игнорирует действия внутри прерванных транзакций. Однако, последовательность действия внутри прерванных транзакций может быть некорректной. Поэтому функция $eval(s,\tau)$ рекурсивно проверяет каждый префикс следа $\tau$.

Благодаря функции $eval$ множество $\llbracket P \rrbracket(s)$ будет содержать только корректные следы выполнения программы.

\chapter{Условие корректности транзакционной памяти}
Одним из способов проверки корректности реализации программной транзакционной памяти является условие согласованности. Разработка условия согласованности усложняется необходимостью гарантировать корректное состояние объектов транзакционной памяти внутри действующих транзакций. Поэтому необходимо установить связь между ожиданиями программиста от выполнения программы в условиях транзакционной памяти и условием согласованности. 

Отношение уточнения формализует ожидания программиста от выполнения программы в условиях транзакционной памяти. В данной главе мы рассмотрим отношение уточнения абстрактной транзакционной памяти конкретной, представленное в работе \cite{tms_article}, для введённого ранее языка программирования. Данное отношение заключается в том, что если конкретная транзакционная память $\mathcal{T}_C$ уточняет абстрактную $\mathcal{T}_A$, то любое заключение о поведении программы относительно объектов наблюдения в условиях $\mathcal{T}_A$ распространяется на случай $\mathcal{T}_C$. Одним из объектов нашего наблюдения будет завершение следа программы командой $fault$. Используя отношение уточнения, мы можем утверждать, что если программа в условиях абстрактной транзакционной памяти не завершилась командой $fault$, то это поведение распространяется и на случай конкретной транзакционной памяти. Это гарантирует корректное состояние объектов транзакционной памяти внутри действующих транзакций. 

В данной главе мы рассмотрим TMS условие согласованности транзакционной памяти, представленное в работе \cite{tms_article}. Условие TMS заключается в том, что для всех зафиксированных транзакций конкретной истории существует подтверждение одной абстрактной историей, и для каждого ответа на запрос прерванной или действующей транзакции конкретной истории существует подтверждение абстрактной историей. В следующей главе нами будет обсуждаться равносильность TMS отношения между абстрактной и конкретной транзакционной памятью и отношения уточнения абстрактной транзакционной памяти конкретной, но при условии, что абстрактная транзакционная память удовлетворяет некоторых свойствам. Этот факт установлен в работе \cite{tms_article}. Благодаря этой равносильности можно говорить о корректности транзакционной памяти в терминах отношения уточнения. 

\section{TMS отношение}
Выбор условия корректности транзакционной памяти является важным моментом при её разработке. В данном разделе мы рассмотрим условие корректности TMS (transactional memory specification), описанное в работе \cite{tms_article}. У данного условия есть множество достоинств. Во-первых, TMS отношение между абстрактной и конкретной транзакционной памятью равносильно отношению уточнения абстрактной памяти конкретной. Благодаря этому можно рассуждать о корректности транзакционной памяти и анализировать поведение клиентской программы в терминах отношения уточнения. В следующей главе нами будет рассмотрена теорема, формализующая этот факт. Во-вторых, данное условие обеспечивает гибкость реализации транзакционной памяти. Разработчик может выполнять необходимое число оптимизаций в конкретной реализации транзакционной памяти.

Прежде чем перейти к рассмотрению TMS отношения, введём необходимые понятия, используемые в работе \cite{tms_article}. При разработке транзакционной памяти особое внимание уделяется порядку выполнения непересекающихся транзакций, так как потоки могут обмениваться информацией о завершении транзакций посредством глобальных переменных. Этот порядок важен для TMS отношения. Приведём его формальное определение.

\begin{mydefinition}\label{order}
Пусть $\psi = (\_, t, \_)$ и $\psi' = (\_, t', \_)$ --- два действия истории $H$. Действие $\psi$ выполнено до запуска действия $\psi'$ в истории $H$, что обозначается $\psi \prec_H \psi'$, если $H = H_1\psi{H_2}H'_2\psi'{H_3}$ и выполняется одно из условий:  
\begin{enumerate}[label = (\roman*)]
\item Действия $\psi$ и $\psi'$ принадлежат одному потоку, то есть $t = t'$;
\item Транзакция действия $\psi$ завершается до запуска транзакции действия $\psi'$, то есть $(\_, t', txbegin) \in H'_2\psi'$ и либо $(\_, t, committed) \in \psi{H_2}$, либо $(\_, t, aborted) \in \psi{H_2}$. 
\end{enumerate}
Транзакция $T$ выполнена до начала действия $\psi'$, что обозначается $T \prec_H \psi'$, если $\psi \prec_H \psi'$ для любого действия $\psi \in T$. 
Транзакция $T$ выполняется до начала транзакции $T'$ в истории $H$, что обозначается $T \prec_H T'$, если $T \prec_H T'(1)$.
\end{mydefinition}

Условие TMS получено из opacity условия корректности транзакционной памяти, представленного в работе \cite{opacity_article}, путём ослабления некоторых требований. Условие opacity равносильно отношению уточнения для определённого языка программирования. Опишем это условие. Конкретная реализация транзакционной памяти $\mathcal{T}_C$ находится в opacity отношении с абстрактной транзакционной памятью $\mathcal{T}_A$, если для каждой истории $H \in \mathcal{T}_C$ существует история $S \in \mathcal{T}_A$ такая, что все действия потоков в обеих историях совпадают, и сохраняется порядок выполнения непересекающихся транзакций. Однако в языке программирования, представленном в работе \cite{opacity_article}, значения локальных переменных после прерывания транзакций не принимают свои прежние значения, в отличие от языка программирования, представленного в работе \cite{tms_article} и рассматриваемого в данной работе. 

Обсудим, как условие TMS ослабляет условие opacity. Ключевой чертой отношения opacity является то, что поведение всех транзакций, включая прерванные и действующие, в конкретной истории должно подтверждаться одной абстрактной историей. TMS ослабляет это условие, требуя подтверждения только всех зафиксированных транзакций в конкретной истории одной абстрактной историей. Каждый ответ на запрос, кроме $aborted$ действия, в прерванных и действующих транзакциях может быть подтверждён отдельной абстрактной историей. Это условие позволяет выполнять в конкретной транзакционной памяти необходимое количество оптимизаций. 

Для определения TMS отношения необходимо определить opacity отношение между двумя произвольными историями. 

\begin{mydefinition}\label{opacity}
История $H$ находится в отношении opacity с историей $S$, что обозначается $H \sqsubseteq_{op} S$, если $\forall \psi, \psi' \; (\psi \in S \iff \psi \in H ) \land (\psi \prec_H \psi' \implies \psi \prec_S \psi' ).$
\end{mydefinition}

Как было отмечено выше, TMS требует, чтобы каждый ответ на запрос в истории взаимодействия с конкретной транзакционной памятью $H$ был подтверждён абстрактной историей $S_{\psi}$. История $S_{\psi}$ включает транзакцию действия $\psi$ и подмножество транзакций истории $H$, чьи действия подтверждают ответ $\psi$. Следующее определение возможной предыстории (possible past) истории $H = H_1\psi$, приведённое в работе \cite{tms_article}, описывает, какие транзакции истории $H$ могут быть включены в историю $S_{\psi}$. Также следует отметить, что если прерванная или ожидающая фиксацию транзакция входит в возможную предысторию, то в истории $S_{\psi}$ она будет зафиксированной. Дадим формальное определение возможной истории и поясним его на примере, приведённом в работе \cite{tms_article}.

\begin{mydefinition}\label{possible_past}
История $H_{\psi} = H'_1\psi$ --- возможная предыстория истории $H = H_1\psi$, где $\psi$ --- ответ на запрос, который не является $committed$ или $aborted$ действием, если :
\begin{enumerate}[label = (\roman*)]
\item $H'_1$ подпоследовательность $H_1$;
\item $H_{\psi}$ состоит из транзакции действия $\psi$ и некоторых видимых транзакций истории $H: tx(H_{\psi}) \subseteq \{ txof(\psi, H)\} \cup visible(H)$;
\item Из всех транзакций, принадлежащих истории $H$ и предшествующих транзакции $T\in H_{\psi}$, $H_{\psi}$ включает только зафиксированные:
\begin{align*}
\forall \; T \in tx(H_{\psi}) \; \forall \; T' \in \; &tx(H) \; T' \prec_H T \implies \\ &(T' \in tx(H_{\psi}) \iff T' \in committed(H)).
\end{align*}
\end{enumerate}
$TMSpast(H)$ --- множество возможных предысторий истории $H$.
\end{mydefinition}

\begin{figure}
\centering
\includegraphics[width=\textwidth]{img/trace.png}
\caption{\label{fig:trace} след программы} 
\end{figure}

Рассмотрим историю $H$ следа, изображенного на рисунке \ref{fig:trace}. Одна из возможных предысторий $H_{\psi}$ истории $H$ состоит из транзакций $T_1$, $T_4$ и $T_5$. Согласно пункту $(ii)$ определения \ref{possible_past} транзакция действия $\psi$ всегда включена в возможную предысторию, а действующие транзакции всегда исключены, так как они не влияют на действие $\psi$. Из пункта $(iii)$ определения \ref{possible_past} следует, что если транзакция $T$ включена в $H_{\psi}$, то из всех видимых и завершившихся к моменту запуска $T$ транзакций в $H_{\psi}$ включаются только зафиксированные транзакции. Поэтому, если транзакции $T_4$ и $T_5$ включены в $H_{\psi}$, то транзакция $T_1$ тоже принадлежит $H_{\psi}$, а транзакция $T_3$ не принадлежит. Транзакция $T_3$ не может быть включена в $H_{\psi}$, так как после прерывания транзакции $T_3$ и перед запуском транзакции $T_5$ поток $t_2$ может сообщить о прерывании транзакции $T_3$ потоку $t_3$, используя, например, глобальную переменную $g$, как показано на рисунке \ref{fig:trace}. Следовательно, транзакция $T_3$ не влияет на выполнение действия $\psi$, и при замене конкретной транзакционной памяти абстрактной поведение программы не меняется. В противоположность этому, транзакция $T_4$ может быть включена в $H_{\psi}$, даже если она прерванная или ожидает фиксацию. У транзакции $T_5$ нет способа узнать о статусе транзакции $T_4$, так как глобальные переменные не доступны внутри транзакций. Следовательно, при изменении статуса транзакции $T_4$ с прерванной на зафиксированную при замене конкретной транзакционной памяти абстрактной, поведение программы не изменится. Транзакция $T_2$ может быть исключена из истории $H_{\psi}$ вне зависимости от её статуса по той же причине. 

Прежде чем перейти к определению $TMS$ отношения, опишем способ изменения статуса транзакций возможной предыстории, представленный в работе \cite{tms_article}. Опишем завершение истории $H\psi$ фиксацией транзакций, находящихся в процессе ожидания фиксации, и завершённую возможную предысторию.
\begin{mydefinition}\label{suff_comm_compl}
История $H^c$ --- завершение истории $H\psi$, если $H^c = H\psi{H'}$, где $H'$ состоит из $committed$ и $aborted$ действий, и каждая транзакция в $H^c$, возможно за исключением транзакции действия $\psi$, завершённая. $H^c = H\psi{H'}$ --- завершение истории $H\psi$ фиксацией транзакций, если $H'$ состоит только из $committed$ действий. Множества завершений истории и завершений истории фиксацией транзакций обозначим $comp(H)$ и $ccomp(H)$ соответственно.
История $H^c_{\psi}$ --- завершённая возможная предыстория истории $H = H_1\psi$, если $H^c_{\psi}$ --- завершение фиксацией транзакций истории, полученной из возможной предыстории $H'_1\psi$ истории $H$ заменой всех $aborted$ действий в $H'_1$ действиями $committed$. Множество завершённых возможных предысторий истории $H$ обозначим $cTMSpast(H)$: 
\begin{align*}
&cTMSpast(H_1\psi) = \\
&\qquad \{H^c_{\psi} \; | \; \exists \; H'_1  \; H'_1\psi \in TMSpast(H_1\psi) \land 
H^c_{\psi} \in ccomp(com(H'_1)\psi) \}, \\
&\text{где} \; |com(H'_1)| = |H'_1| \; \text{и} \\
& \qquad com(H'_1)(i) = \\
&\qquad \qquad (if \left (H'_1(i) = (a, t, aborted)\right)\; then \; (a, t, committed) \; else \; H'_1(i)).
\end{align*}
\end{mydefinition}

Рассмотрим завершённую возможную предысторию истории, изображенной на рисунке \ref{fig:trace}, состоящую из транзакций $T_1$, $T_4$ и $T_5$, где статус транзакции $T_4$ изменён, при необходимости, на зафиксированную. Отметим, что у истории $H$ есть завершение, только если $H = H_1\psi$ и все транзакции в $H$, возможно за исключением транзакции действия $\psi$, ожидают фиксацию или завершены. Кроме того, $cTMSpast(H_1\psi) \neq \emptyset$, только если $\psi$ --- ответ за запрос.

Перейдём к определению отношения TMS между реализациями транзакционной памяти, сравнивая историю, полученную из взаимодействия программы с конкретной транзакционной памятью, с подобной абстрактной историей $S$. В данном определении от истории $S$ требуется сохранение порядка выполнения непересекающихся транзакций в $H$. Это требование важно для уточнения абстрактной транзакционной памяти конкретной, так как сохранение порядка следования транзакций важно для взаимодействия потоков. Также отметим, что каждый ответ на запрос действующей транзакции в конкретной истории подтверждается отдельной абстрактной историей.
\begin{mydefinition}\label{tms}
История H находится в отношении TMS с транзакционной памятью $\mathcal{T}$, что обозначается $H \sqsubseteq_{tms} \mathcal{T}$, если выполняются следующие требования:
\begin{enumerate}[label = (\roman*)]
\item $\exists \; H^c \in comp(H|_{\neg live})$, $S \in \mathcal{T}$ такие, что $H^c|_{com} \sqsubseteq_{op} S$, где $\cdot|_{\neg live}$ и $\cdot|_{com}$ --- проекции на недействующие и зафиксированные транзакции соответственно;
\item Для каждого ответа на запрос $\psi$, который не является $committed$ или $aborted$ действием, и истории $H = H_1\psi{H_2}$ существуют истории $H^c_{\psi} \in cTMSpast(H_1\psi)$ и $S_{\psi} \in \mathcal{T}$ такие, что $H^c_{\psi} \sqsubseteq_{op} S_{\psi}$. 
\end{enumerate}
Транзакционная память $\mathcal{T}_C$ находится в отношении TMS c транзакционной памятью $\mathcal{T}_A$, что обозначается $\mathcal{T}_C \sqsubseteq_{tms} \mathcal{T}_A$, если любая история $H \in \mathcal{T}_C$ находится в TMS отношении с $\mathcal{T}_A$, то есть $H \sqsubseteq_{tms} \mathcal{T}_{A}$.
\end{mydefinition}

\section{Уточнение транзакционной памяти}
Задача разработки многопоточных приложений упрощается при использовании транзакционной памяти. Как правило, программисты при написании программ предполагают, что поведение программы не изменится, если заменить неэффективную, корректную реализацию транзакционной памяти на её оптимизированный вариант. Уточнение наблюдейний формализует ожидания программиста от выполнения программы в условиях транзакционной памяти.

В данном разделе мы рассмотрим отношение уточнения абстрактной транзакционной памяти конкретной транзакционной памятью, описанное в работе \cite{tms_article}. Транзакционная память, выполняющая каждую транзакцию атомарно, может быть абстрактной реализацией, а эффективная транзакционная память - конкретной реализацией. Рассмотрим след $\tau$ клиентской программы $P$. В работе \cite{tms_article} уточняется, что объектами нашего наблюдения будут: последовательность нетранзакционных действий следа $\tau$, последовательность действий зафиксированных транзакций каждого потока следа $\tau$, завершение следа $\tau$ действием $fault$. Из уточнения абстрактной транзакционной памяти $\mathcal{T}_A$ конкретной транзакционной памятью $\mathcal{T}_C$ следует, что все наблюдения, полученные при выполнении программы $P$ с использованием $\mathcal{T}_C$, могут быть получены и при использовании $\mathcal{T}_A$. Следовательно, любое заключение о поведении программы относительно выше описанных объектов наблюдения в условиях $\mathcal{T}_A$ распространяется на случай $\mathcal{T}_C$. Так как действия внутри прерванных и действующих транзакций, кроме действия $fault$, не являются объектами нашего наблюдения, мы не может сделать никаких выводов на их счёт. Однако, мы можем быть уверены, что если программа не была завершена с ошибкой в условиях $\mathcal{T}_A$, то это сохраняется и при использовании $\mathcal{T}_C$.

Действие $\varphi \in \tau$ --- транзакционное, если $\varphi \in T$ для некоторой транзакции $T \in \tau$, иначе нетранзакционное. Обозначим $\tau|_{trans}$ и $\tau|_{\neg trans}$ проекции следа $\tau$ на транзакционные и нетранзакционные действия соответственно.

Приведём формальные определения для объектов наблюдения и отношения уточнения. 

\begin{mydefinition}
Пусть $observable_t(\tau)$ --- поведение потока $t$ следа $\tau$. $observable_t(\tau)$ равно $\lightning$, если $\tau|_t$ заканчивается действием $fault$, иначе $(\tau|_t)|_{obs}$, где $\cdot|_{obs}$ --- проекция на нетранзационные действия и действия зафиксированных транзакций.
\end{mydefinition}

\begin{mydefinition}
Транзакционная память $\mathcal{T}_C$ уточняет транзакционную память $\mathcal{T}_A$, что обозначается $\mathcal{T}_C \preceq \mathcal{T}_A$, если для каждой программы $P$, состояния $s$ и следа $\tau \in \llbracket P \rrbracket(s)$ выполняются следующие требования: \begin{enumerate}[label=(\roman*)]
\item $\exists \; \tau' \in \llbracket P, \mathcal{T}_A \rrbracket(s)$ такой, что $\tau'|_{\neg trans} = \tau|_{\neg trans}$;
\item $\exists \; \tau'_t \in \llbracket P, \mathcal{T}_A \rrbracket(s)$ такой, что $observable_t(\tau'_t) = observable_t(\tau)$.
\end{enumerate} 
\end{mydefinition}

\chapter{Доказательство теоремы о равносильности TMS отношения и уточнения абстрактной транзакционной памяти}
Данная глава будет посвещена теореме о равносильности $TMS$ отношения между конкретной и абстрактной транзакционной памятью и уточнения абстрактной транзакционной памяти, удовлетворяющей определённым свойствам замкнутости, конкретной транзакционной памятью. Теорема сформулирована и доказана в работе \cite{tms_article}.

В данной работе будет представлено более подробное доказательство теоремы, чем в источнике \cite{tms_article}. Мы также покажем, что доказательство данной теоремы \cite{tms_article} устойчиво к введению команды явного завершения транзакций. 

Для того, чтобы сформулировать свойства замкнутости, введём определение расширения  истории транзакционной памяти мгновенно прерванными транзакциями и завершения истории транзакционной памяти.  
\begin{mydefinition} История $H_a$ --- расширение истории $H$ мгновенно прерванными транзакциями, если $H$ --- подпоследовательность $H_a$ и выполняются следующие требования для действия $\psi$ такого, что $\psi \in H_a$ и $\psi \notin H$:
\begin{enumerate}[label=(\roman*)]
\item $\psi \in \{(\_, \_, txbegin), (\_, \_, aborted)\}$.
\item Если $\psi = (\_, t, txbegin)$, тогда $H_a = H'_a\psi(\_, t, aborted)\_$, где $H'_a \in \{\varepsilon, \_(\_, t, committed), \_(\_, t, aborted)\}$.
\item Если $\psi = (\_, t, aborted)$, тогда существует действие $\psi' \notin H$ такое, что $\psi' = (\_, t, txbegin)$ и $H_a = \_\psi\psi'\_$. 
\end{enumerate}
Обозначим множество всех расширений истории $H$ мгновенно прерванными транзакциями addab(H).
\end{mydefinition}

\begin{mydefinition} История $H_c$ --- завершение истории $H$, если $H$ --- подпоследовательность $H_c$, $pending(H_c) = \emptyset$ и выполняется следующее требование для действия $\psi$ такого, что $\psi \in H_c$ и $\psi \notin H$: $$H_c = \_(\_, t, txcommit)\psi\_, \psi \in \{committed, aborted\}.$$
История $H_c$ завершает каждую транзакцию в $H$, ожидающую фиксацию, добавлением $committed$ или $aborted$ действия. Обозначим множество всех завершений истории $H$ $nicomp(H)$.
\end{mydefinition}

В условии теоремы абстрактная транзакционая память должна удовлетворять определенным свойствам замкнутости. Сформулируем требуемые свойства замкнутости:
\begin{enumerate}
\item Транзакционная память $\mathcal{T}$ замкнута относительно мгновенного прерывания транзакций, если допускает добавление мгновенно прерванных транзакций в любую историю. Формально, если $H \in \mathcal{T}$, то для любой истории $H' \in addab(H)$ выполняется $H' \in \mathcal{T}$.  
\item Транзакционная память $\mathcal{T}$ замкнута относительно удаления ответов на запросы, если допускает удаление ответов транзакционной памяти, которые являются последними действиями потоков. Формально, если $H_1(\_, t, aborted)H_2 \in \mathcal{T}$ или $H_1(\_, t, committed)H_2 \in \mathcal{T}$ при $H_2|_t = \varepsilon$, то выполняется $H_1H_2 \in \mathcal{T}$.
\item Транзакционная память $\mathcal{T}$ замкнута относительно удаления действующих и прерванных транзакций, если допускает удаление действующих и прерванных транзакций. Формально, если $H \in \mathcal{T}$, то $H' \in \mathcal{T}$ для любой истории $H'$ такой, что $committed(H') = committed(H)$, $pending(H') = pending(H)$, $live(H') \subseteq live(H)$ и $aborted(H') \subseteq aborted(H)$. 
\item Транзакционная память $\mathcal{T}$ замкнута относительно завершения транзакций, ожидающих фиксацию, если допускает завершение любой транзакции, ожидающей фиксацию. Формально, если $H \in \mathcal{T}$, то $nicomp(H) \cap \mathcal{T} \neq \emptyset$. 
\end{enumerate}

Сформулируем теорему о равносильности $TMS$ отношения и уточнения абстрактной транзакционной памяти.

\begin{theorem}\label{theorem1} Пусть $\mathcal{T}_C$ и $\mathcal{T}_A$ --- конкретная и абстрактная транзакционная память соответственно, тогда :
\begin{enumerate}[label=(\roman*)]
\item Если $\mathcal{T}_A$ удовлетворяет 1 и 2 свойствам замкнутости, тогда $\mathcal{T}_C \sqsubseteq_{tms} \mathcal{T}_A \implies \mathcal{T}_C \preceq \mathcal{T}_A$;
\item Если $\mathcal{T}_A$ удовлетворяет 3 и 4 свойствам замкнутости, тогда $\mathcal{T}_C \preceq \mathcal{T}_A \implies \mathcal{T}_C \sqsubseteq_{tms} \mathcal{T}_A $.
\end{enumerate}
\end{theorem}

\begin{lemma}\label{sufficiency1}
Пусть $\tau = \tau_1\psi\tau_2 \in \llbracket P \rrbracket (s)$, где действие потока $t_0$ $\psi$ --- ответ на запрос, при этом $\psi \notin \{(\_, t_0, committed),(\_,t_0, aborted)\}$ и $\tau_2$ --- последовательность примитивных действий потока $t_0$. Тогда для любой истории $H^c_{\psi} \in cTMSpast(history(\tau))$ существует след $\tau_{\psi} \in \llbracket P \rrbracket (s)$ такой, что $history(\tau_{\psi})|_{\neg abortedtx} = H^c_{\psi}$ и $\tau_{\psi}|_{t_0} = \tau|_{t_0}$. 
\end{lemma}
\begin{myproof}
Построим след $\tau_{\psi}$. Пусть $history(\tau) = H_1\psi$. Так как $H^c_{\psi} \in cTMSpast(H_1\psi)$, то по определению \ref{def1} % изменить ссылку на определение
существуют $H'_1$, $H''_1$ и $H^{cc}$ такие, что $$H'_1\psi \in TMSpast(H_1\psi) \land H''_1 = com(H'_1) \land H^c_{\psi} = H''_1{\psi}H^{cc} \in ccomp(H''_1\psi).$$

После завершения транзакций потоки могут обмениваться информацией о статусе транзакций посредством глобальных переменных. Информация о статусе транзакций может быть передана транзакционной памяти посредством локальных и глобальных переменных. Поэтому для построения следа $\tau_{\psi}$ приведенных выше преобразований недостаточно. Пусть $\psi^b$ --- последнее $txbegin$ действие в $H'_1\psi$, тогда для некоторых следов $\tau^b_1$ и $\tau^b_2$ получаем, что $\tau = \tau^b_1\psi^b\tau^b_2\psi\tau_2$. Пусть $\tau^I_t$ --- префикс $\tau|_t$, который завершается последним действием интерфейся потока $t$ в истории $H'_1\psi$, при отсутствии таких действий $\tau^I_t = \varepsilon$. Пусть $\tau^N_t$ --- префикс $\tau|_t$, который завершается последним не транзакционным действием потока $t$ в $\tau^b_1$, при отсутствии таких действий $\tau^N_t = \varepsilon$. Пусть $\tau_{t_0} = \tau|_{t_0}$ и для каждого $t \neq t_0$ $\tau_t = \tau^I_t$, если $|\tau^N_t| < |\tau^I_t|$, иначе $\tau_t = \tau^N_t$. Пусть $\tau'|_t = \tau_t$. Далее для построения следа $\tau_{\psi}$ преобразуем $H'_1$ в $H''_1$ и $H^c_{\psi}$. Пусть $\psi_1 = (a, t, aborted)$, $\psi_2 = (a, t, committed)$. Введем след $\tau''$ такой, что $|\tau''| = |\tau'|$,  и $ \tau''(i) = if \; (\tau'(i) = \psi_1 \; \land \; \tau'(i) \in H'_1) \; then \; \psi_2 \; else \; \tau'(i).$ Пусть $\tau_{\psi} = \tau''H^{cc}$

Докажем, что $\tau_{\psi}|_{t_0} = \tau|_{t_0}$. Пусть $T = txof(\psi, H_1\psi)$. Тогда по определению \ref{def1}(ii) %изменить ссылку на определение
$T \in tx(H'_1\psi)$. Следовательно по определению \ref{def1}(iii) %изменить ссылку на определение
\begin{equation}\label{eq:transform4iii}
\forall T' \; T' \prec_{H'_1\psi} T \iff T' \prec_{H_1\psi} T \land T' \in committed(H_1\psi),
\end{equation}
поэтому $(H'_1\psi)|_{t_0}$ не содержит прерванных транзакций. Тогда $\tau''|_{t_0} = \tau'|_{t_0} = \tau|_{t_0}$. Так как $H^{cc}|_{t_0} = \varepsilon$, то $\tau_{\psi}|_{t_0} = \tau''|_{t_0} = \tau|_{t_0}.$

\begin{figure}
\centering
\includegraphics[width=\textwidth]{img/cases.png}
\caption{\label{fig:cases} Расположение $\tau^N_t, \tau^I_t, \psi^b$} 
\end{figure}
Докажем, что след $\tau_{\psi} \in \llbracket P \rrbracket (s)$. Начнём с анализа построения следа $\tau_t$ при $t \neq t_0$. Рассмотрим три возможных варианта расположения $\tau^N_t$, $\tau^I_t$, $\psi^b$ относительно друг друга, изображенные на рисунке \ref{fig:cases}. В соответствии с выбором следа $\tau^N_t$ в случаях $(a)$ и $(b)$ фрагмент следа $\tau$ между концом $\tau^N_t$ и действием $\psi^b$ может содержать только транзакционные действия потока $t$. В соответствии с выбором следа $\tau^I_t$ и $\psi^b$ в случае $(c)$ фрагмент следа $\tau$ между действием $\psi^b$ и концом $\tau^I_t$ не может содержать действие $txbegin$ потока t. Из-за выбора $\tau^N_t$ данный фрагмент содержит только транзакционные действия потока $t$. Более того эти действия принадлежат либо транзакции, запущенной действием $\psi^b$, либо транзакции, которая была запущена до действия $\psi^b$. В соответствии с выбором $\psi^b$ за $\psi^b$ следуют только транзакционные действия потока $t_0$, которые принадлежат либо транзакции, запущенной действием $\psi^b$, либо транзакции, которая была запущена до действия $\psi^b$. Из данного анализа следует, что преобразования следа $\tau$ в $\tau'$ состоит из двух действий:
\begin{enumerate}[label=(\roman*)]
\item Удаление действий, следующих за действием $\psi^b$, за исключением действий уже запущенных транзакций.
\item Удаление некоторых суффиксов потоков, содержащих только транзакционные действия. 
\end{enumerate}
Так как у транзакций нет доступа к глобальным переменным, то на них не влияют действия других потоков. Согласно определению множества $A'(P)$ (рисунок \ref{fig:actions}), множество $\llbracket P\rrbracket(s)$ содержит префиксы следа $\tau \in \llbracket P\rrbracket(s)$. Следовательно, $\tau' \in \llbracket P\rrbracket(s)$.

Покажем, что след $\tau''$ корректен, ссылаясь на случаи $(a-c)$. Пусть $T = txof(\psi^b, H_1\psi)$, тогда $T \in H'_1\psi$ из-за выбора действия $\psi^b$. По определению \ref{def1}(iii) % изменить ссылку
получаем \eqref{eq:transform4iii}. Следовательно, в случаях $(a)$ и $(b)$ $\tau'|_t$ не содержит прерванных транзакций, которые принадлежат $H'_1\psi$. В случае $(c)$ прерванная транзакция, принадлежащая $H'_1\psi$, может быть только последней транзакцией $\tau'|_t$. Как было доказано выше, $(H'_1\psi)|_{t_0}$ не содержит прерванных транзакций. Следовательно, за прерванными транзакциями следа $\tau'$, чей статус был изменён при построении $\tau''$, нет действий. Кроме того, $\llbracket P\rrbracket(s)$ допускает произвольное прерывание и фиксацию транзакций. Следовательно, $\tau'' \in \llbracket P\rrbracket(s)$. Так как след $\tau_{\psi}$ получен из следа $\tau''$ фиксацией транзакций, находящихся в ожидании фиксации, а $\llbracket P\rrbracket(s)$ допускает произвольную фиксацию транзакций, то  $\tau_{\psi} \in \llbracket P\rrbracket(s)$.

Наконец, покажем, что $history(\tau_{\psi})|_{\neg abortedtx} = H^c_{\psi}$. Так как $\tau_{\psi} = \tau''H^{cc}$, и $H^{cc}$ содержит только зафиксированные действия, тогда достаточно показать, что $history(\tau'')|_{\neg abortedtx} = H''_1\psi$. Получаем, что
\begin{align*}
history(\tau_{\psi})|_{\neg aborted} = &\quad history(\tau''H^{cc})|_{\neg aborted} = \\
                                 &\quad history(\tau'')|_{\neg abortedtx}H^{cc} = H''_1{\psi}H^{cc} =H^c_{\psi}.
\end{align*}
В соответствии с выбором $\tau^I_t$ для $t \neq t_0$ каждая транзакция в $(H'_1\psi)|_t$ также находится в $\tau^I_t$. Следовательно $H'_1\psi$ --- подпоследовательность истории $history(\tau')$. По определению $\tau''$ и $H''_1$, $H''_1\psi$ --- подпоследовательность $history(\tau'')$. Так как $H''_{\psi}$ не содержит прерванных транзакций, то $H''_1\psi$ --- подпоследовательность $history(\tau'')|_{\neg abortedtx}$.

Для того, чтобы доказать, что $history(\tau'')|_{\neg abortedtx} = H''_1\psi$, осталось показать, что каждая не прерванная транзакция в $history(\tau'')$ содержится в $H''_1\psi$. Так как след $\tau''$ получен из следа $\tau'$ изменением статуса транзакций, принадлежащих истории $H'_1\psi$, достаточно показать, что каждая не прерванная транзакция в $history(\tau')$ содержится в $H'_1\psi$. Рассмотрим все возможные случаи:
\begin{itemize}
\item[--] Рассмотрим поток $t \neq t_0$ и $\tau'|_t = \tau^N_t \neq \varepsilon$. Пусть $\chi^N_t$ --- последнее действие в $\tau^N_t$ и $T = txof(\psi^b, H_1\psi) \in H'_1\psi$. По определению \ref{def1}(iii) % изменить ссылку на определение
получаем \eqref{eq:transform4iii}. Так как $\chi^N_t$ предшествует действию $\psi^b$ в $H_1\psi$, то для любой транзакция $T'$, принадлежащей $\tau'|_t$, выполняется отношение $T' \prec_{H_1\psi} T$. Тогда согласно \eqref{eq:transform4iii}, если $T'$ --- зафиксированная транзакция, тогда она принадлежит $H'_1\psi$. Отсюда следует, что $history(\tau'')|_{\neg abortedtx} = H''_1\psi$.
\item[--] Рассмотрим поток $t \neq t_0$ и $\tau'|_t = \tau^I_t \neq \varepsilon$. Пусть $\psi^I_t$ --- последнее действие в $\tau^I_t$. Пусть $T = txof(\psi^I_t, H_1\psi)$. $T \in H'_1\psi$ в соответствии с выбором $\tau^I_t$. По определению \ref{def1} % изменить ссылку
получаем \eqref{eq:transform4iii}. Так как любая транзакция $T'$ из истории $history(\tau'|_t)$ является либо транзакцией $T$, либо $T' \prec_{(H_1\psi)|_t} T$, то из \eqref{eq:transform4iii} следует, что $history(\tau'')|_{\neg abortedtx} = H''_1\psi$.
\item[--] Рассмотрим поток $t = t_0$. Пусть $T = txof(\psi, H_1\psi) \in H'_1\psi$. Тогда по определению \ref{def1}(iii) % изменить ссылку на определение
получаем \eqref{eq:transform4iii}. Так как любая транзакция $T'$ из истории $history(\tau'|_{t_0})$ является либо транзакцией $T$, либо $T' \prec_{(H_1\psi)|_{t_0}} T$, то из \eqref{eq:transform4iii} следует, что $history(\tau'')|_{\neg abortedtx} = H''_1\psi$.
\end{itemize}
\end{myproof}
\begin{lemma}\label{sufficiency2}
Рассмотрим истории $H^i$, $S$ и след $\tau^i$ такие, что $$history(\tau^i) = H^i; \; H^i\downharpoonleft_i = S \downharpoonleft_i; \; H^i \sqsubseteq_{op} S.$$ Тогда существует история $H^{i+1}$ и след $\tau^{i+1}$ такие, что 
\begin{align*}
history(&\tau^{i+1}) = H^{i+1}; \; H^{i+1}\downharpoonleft_{i+1} = S \downharpoonleft_{i+1}; \; H^{i+1} \sqsubseteq_{op} S; \\
&\tau^{i}|_{\neg trans} = \tau^{i+1}|_{\neg trans}; \; \forall \; t \; \tau^{i}|_t = \tau^{i+1}|_t.
\end{align*} \end{lemma}
\begin{myproof}
Пусть $S=S_1\psi{S_2}$, где $|S_1| = i$. По предположению $history(\tau^i)\downharpoonleft_i = H^i\downharpoonleft_i = S\downharpoonleft_i=S_1$. Пусть $\tau^i=\tau_1\tau_2$, где $\tau_1$ --- префикс $\tau^i$ такой, что $history(\tau_1) = S_1$. Из отношения $H^{i} \sqsubseteq_{op} S$ следует, что каждое действие в $history(\tau^i)$ содержится в $S$. Так как $history(\tau_1) = S_1$, то порядок действий сохраняется. Пусть $\tau_2 = \tau_3\psi\tau_4$, тогда $\tau^i = \tau_1\tau_2 = \tau_1\tau_3\psi\tau_4$. Пусть $\psi = (\_, t, \_)$. Если история $history(\tau_3|_t) \neq \varepsilon$, то существует действие $\psi' \in history(\tau_3|_t)$ и $\psi' \preceq_{H^i} \psi$. Тогда действие $\psi' \in S_1$, а этого противоречит тому, что $\psi' \notin history(\tau_1)$. Следовательно, $history(\tau_3|_t) = \varepsilon$. Рассмотрим два случая:
\begin{itemize}
\item[--] $\psi \neq (\_, t, txbegin)$. Пусть $\tau^{i+1} = \tau_1(\tau_3|_t)\psi(\tau_3|_{\neg t})\tau_4$ и $H^{i+1} = history(\tau^{i+1})$. Так как $history(\tau_3|_t) = \varepsilon$, $history(\tau_1) = S_1$ и $|S_1| = i$, то: $$H^{i+1}\downharpoonleft_{i+1} = history(\tau_1(\tau_3|_t)\psi(\tau_3|_{\neg t})\tau_4)\downharpoonleft_{i+1} = S_1\psi = S\downharpoonleft_{i+1}.$$ Также получаем, что 
\begin{alignat}{2}
\tau^{i+1}|_t =& \quad (\tau_1(\tau_3|_t)\psi(\tau_3|_{\neg t})\tau_4)|_t \nonumber \\
              =& \quad (\tau_1|_t)(\tau_3|_t)\psi(\tau_4|_t) \nonumber \\
              =& \quad (\tau_1\tau_3\psi\tau_4)|_t \nonumber \\
              =& \quad \tau^i|_t; \nonumber \\
\tau^{i+1}|_{\neg t} =& \quad (\tau_1(\tau_3|_t)\psi(\tau_3|_{\neg t})\tau_4)|_{\neg t} \nonumber \\
                     =& \quad (\tau_1|_{\neg t})(\tau_3|_{\neg t})(\tau_4|_{\neg t})\nonumber \\
                     =& \quad (\tau_1\tau_3\psi\tau_4)|_{\neg t} \nonumber \\
                     =& \quad \tau^i|_{\neg t}. \nonumber
\end{alignat}
Следовательно, для любого потока $t'$ $\tau^i|_{t'} = \tau^{i+1}|_{t'}$ и $H^{i+1}|_{t'} = H^i|_{t'} = S|_{t'}$. Порядок выполнения двух действий в $H^{i+1}$, который не сохраняется в $H^i$, также существует в истории $S$. Следовательно, $H^{i+1} \sqsubseteq_{op} S$.

Так как $\psi \neq (\_, t, txbegin)$ и $history(\tau_3|_t) = \varepsilon$, то все действия потока $t$ следа $\tau_3$ транзакционные. Следовательно, $$\tau^{i+1}|_{\neg trans} = (\tau_1(\tau_3|_t)\psi(\tau_3|_{\neg t})\tau_4)|_{\neg trans} = (\tau_1\tau_3\psi\tau_4)|_{\neg trans} = (\tau^i)|_{\neg trans}.$$
Следовательно, $\tau^i|_{\neg trans} = \tau^{i+1}|_{\neg trans}$.
\item[--] $\psi = (\_, t, txbegin)$. Предположим, что след $\tau_3$ содержит $committed$ или $aborted$ действие $\psi'$. Тогда $\psi' \prec_{H^{i}} \psi$. Так как $history(\tau_1) = S_1$, то $\psi' \in S_2$. Следовательно, порядок выполнения действий $\psi'$ и $\psi$ в $H^i$ не сохраняется в $S$, что нарушает условие леммы. Из этого следует, что $\tau_3$ не содержит $committed$ или $aborted$ действий. Для любого $t \neq t'$ $\tau_3|_{t'}$ состоит из некоторой последовательности не транзакционных действий, за которой следует последовательность транзакционных действий. $\tau_3|_t$ состоит из транзакционных действий. Пусть $\tau^{i+1} = \tau_1(\tau_3|_{\neg trans})\psi(\tau_3|_{trans})\tau_4$ и $history(\tau^{i+1}) = H^{i+1}$. Так как $history(\tau_3|_{\neg trans}) = \varepsilon$, $history(\tau_1) = S_1$ и $|S_1| = i$, то: $$H^{i+1}\downharpoonleft_{i+1} = history(\tau_1(\tau_3|_{\neg trans})\psi(\tau_3|_{trans})\tau_4)\downharpoonleft_{i+1} = S_1\psi = S\downharpoonleft_{i+1}.$$ Так как для любого потока $t' \neq t$ $\tau_3|_{t'}$ состоит из не транзакционных действий, за которыми следуют транзакционные, то $(\tau_3|_{\neg trans}\psi\tau_3|_{trans})|_{t'} = (\tau_3\psi)|_{t'}$. Так как $\tau_3|_t$ не содержит транзакционных действий, то $\tau_3|_t = (\tau_3|_{\neg trans})|_t$. Следовательно, $(\tau_3|_{\neg trans}\psi\tau_3|_{trans})|_t = (\tau_3\psi)|_t$. Таким образом, для любого $t''$
\begin{align*}
\tau^{i+1}|_{t''} = (\tau_1(\tau_3|_{\neg trans})&\psi(\tau_3|_{trans})\tau_4)|_{t''} = (\tau_1\tau_3\psi\tau_4)|_{t''} = \tau^i|_{t''}; \\   
&H^{i+1}|_{t''} = H^i|_{t''} = S|_{t''}.
\end{align*}
Так как порядок выполнения действий сохраняется, то $H^{i+1} \sqsubseteq_{op} S$. Покажем, что $\tau^{i+1}|_{\neg trans} = \tau^{i}|_{\neg trans}$:
\begin{align*}
\tau^{i+1}|_{\neg trans} &= \quad (\tau_1(\tau_3|_{\neg trans})\psi(\tau_3|_{trans})\tau_4)|_{\neg trans}  \\
                         &= \quad (\tau_1\tau_3\psi\tau_4)|_{\neg trans} \\
                         &= \quad (\tau^i)|_{\neg trans}.
\end{align*}
\end{itemize}
\end{myproof}

\begin{lemma}\label{sufficiency3}
Рассмотрим след $\tau \in \llbracket P \rrbracket (s)$, в котором все транзакции прерываются мгновенно. Пусть $S$ --- такая история, что $history(\tau) \sqsubseteq_{op} S$. Тогда существует след $\tau' \in \llbracket P \rrbracket (s)$ такой, что $history(\tau') = S$, $\tau|_{\neg trans} = \tau'|_{\neg trans}$ и $\forall \; t \; \tau'|_t = \tau|_t$. \end{lemma}
\begin{myproof}
Рассмотрим истории $H$, $S$ и след $\tau$ такие, что $history(\tau) \sqsubseteq_{op} S$ и $history(\tau) = H$. По определению $|H| = |S|$. Для построения следа $\tau'$ построим по индукции последовательность $\tau^i$ $i = 0..|S|$ такую, что
\begin{align}\label{eq:condInd}
\begin{split}
H^i &= history(\tau^i); \; H^i \downharpoonleft_{i} = S \downharpoonleft_{i}; \; H^i \sqsubseteq_{op} S; \\
&\tau|_{\neg trans} = \tau^i|_{\neg trans}; \; \forall \; t \; \tau|_{t} = \tau^i|_{t}
\end{split} 
\end{align}
Пусть $\tau^0 = \tau$, $H^0 = H$. Все условия \eqref{eq:condInd} для $\tau^0$ выполняются. Предположим, что условия \eqref{eq:condInd} выполняются для $\tau^i$. Тогда по лемме \ref{sufficiency2} существует история $H^{i+1}$ и след $\tau^{i+1}$ такие, что
\begin{align*}
history(&\tau^{i+1}) = H^{i+1}; \; H^{i+1}\downharpoonleft_{i+1} = S\downharpoonleft_{i+1}; \; H^{i+1} \sqsubseteq_{op} S; \\ 
&\tau^{i+1}|_{\neg trans} = \tau^i|_{\neg trans}; \; \forall \; t \; \tau^{i+1}|_{t} = \tau^i|_{t}
\end{align*}
Обозначим $\tau^{|S|} = \tau'$. Согласно лемме \ref{sufficiency2}
\begin{align*}
history(&\tau^{|S|}) = H^{|S|} = H^{|S|}\downharpoonleft_{|S|} = S\downharpoonleft_{|S|} = S;\\ 
&history(\tau') = S.
\end{align*}
По свойству транзитивности получаем, что 
\begin{align*}
\tau|_{\neg trans} = \tau'|_{\neg trans}; \; \forall \; t \; \tau|_{t} = \tau'|_{t},
\end{align*}
что и требовалось доказать.
\end{myproof}
Пусть $\tau|_{\neg abortact}$ --- след полученный из следа $\tau$ удалением всех действий внутри прерванных транзакций. Так как в данной модели вычисления все переменные внутри прерванных транзакций принимают свои прежние значения после прерывания транзакции, то, после удаления всех действий внутри прерванных транзакций, корректность следа не нарушается. На основании данных рассуждений сформулируем утверждение.
\begin{mystatement}\label{statement1}
$\forall \; \tau \; \tau \in \llbracket P \rrbracket (s) \implies \tau|_{\neg abortact} \in \llbracket P \rrbracket (s).$
\end{mystatement}
\begin{lemma}\label{sufficiency4}
Пусть H --- история, в которой все прерванные транзакции прерываются мгновенно, и S --- история такая, что $H|_{\neg abortedtx} \sqsubseteq_{op} S$. Тогда существует история $S' \in addab(S)$ такая, что $H \sqsubseteq_{op} S'$. 
\end{lemma}
\begin{myproof}
Пусть $n$ --- число прерванных транзакций истории $H$. Для построения истории $S'$ построим по индукции последовательность $S_i, i = 0 \ldots n$, для которой будут выполнятся следующие условия:
\begin{align}\label{eq:SiInduct}
\begin{split}
|aborted(S_i)| &= i; \; S_i \in addab(S); \; \{\psi| \psi \in S_i\} \subseteq \{\psi | \psi \in H \}; \\ &\forall \; \psi_1, \psi_2 \in S_i: \psi_1 \prec_H \psi_2 \implies \psi_1 \prec_{S_i} \psi_2.
\end{split}
\end{align}

Пусть для $i = 0$ $S_0 = S$ и все требования \eqref{eq:SiInduct} выполнены. Предположим, что $S_i$ удовлетворяет требованиям \eqref{eq:SiInduct}. Построим $S_{i+1}$ из $S_i$. Пусть $H = H_1\psi_{b}H_2\psi_{a}H_3$, где $\psi_b = (\_, t, txbegin)$, $\psi_a = (\_,t, aborted)$, $H_2|_t = \varepsilon$ и $$\neg \; \exists \; \psi' \; \psi' = (\_, \_, txbegin) \in H_1 \land txof(\psi', H) \in aborted(H) \land \psi' \notin S_i.$$

Транзакция $\psi_b\psi_a$ --- первая транзакция в истории $H$, которая не принадлежит $S_i$. Рассмотрим два случая:
\begin{itemize}
\item[--] $H_1$ не содержит $committed$ или $aborted$ действий. Пусть $S_{i+1} = \psi_b\psi_{a}S_i$. Нужно показать, что для любого $\psi' \in S_i$ выполняется $\psi' \prec_H \psi_b \implies \psi' \prec_{S_{i+1}} \psi_b$ или $\psi_a \prec_H \psi' \implies \psi_a \prec_{S_{i+1}} \psi'$. Согласно конструкции $S_{i+1}$ выполняется последнее условие. $H_1$ не может содержать $committed$ или $aborted$ действий, поэтому $H_1$ не содержит действий потока $t$. Следовательно, отношение $\psi' \prec_H \psi_b$ не выполняется для любого $\psi'$. 
\item[--] $H_1$ содержит $committed$ или $aborted$ действия. Пусть $\psi$ --- последнее $committed$ или $aborted$ действие в $S_i$, которое также принадлежит $H_1$. Пусть $S_{i} = S'\psi{S''}$, $S_{i+1} = S'\psi\psi_b\psi_a{S''}$. Покажем, что для любого $\psi' \in S_i$ выполняется $\psi' \prec_H \psi_b \implies \psi' \prec_{S_{i+1}} \psi_b$ или $\psi_a \prec_H \psi' \implies \psi_a \prec_{S_{i+1}} \psi'$.

Предположим, что $\psi' \prec_{H} \psi_b$ для $\psi' \in S_i$, тогда $\psi' \in H_1$. В соответствии с выбором $\psi_b$, $\psi_a$, $\psi$ все $committed$ и $aborted$ действия из $H_1$ принадлежат $S'\psi$. Если $\psi'$ --- $committed$ или $aborted$ действие, тогда $\psi' \in S'\psi$. Из построения $S_{i+1}$ следует, что $\psi' \prec_{S_{i+1}} \psi_b$. Если $\psi'$ --- действие потока $t$, тогда $\psi'$ либо $committed$ или $aborted$ действие, либо $\psi'$ предшествует такому действию $\psi'' \in S_i$ потока $t$ в $H_1$: $\psi' \prec_{H_1} \psi''$. Тогда $\psi' \prec_{S'\psi} \psi''$ и $\psi' \prec_{S_{i+1}} \psi''$. Следовательно, $\psi'' \prec_{S_{i+1}} \psi_b$ и $\psi' \prec_{S_{i+1}} \psi_b$. 

Предположим, что $\psi_a \prec_{H} \psi'$ для $\psi' \in S_i$, тогда $\psi' \in H_3$. Если $\psi' = (\_,\_, txbegin)$, тогда $\psi \prec_{H} \psi'$. Так как для $S_i$ выполняются условия \eqref{eq:SiInduct}, то $\psi \prec_{S_i} \psi'$ и $\psi' \in S''$. Тогда из построения $S_{i+1}$ следует, что $\psi_a \prec_{S_{i+1}} \psi'$. Если $\psi'$ --- действие потока $t$, тогда $\psi'$ либо $txbegin$ действие, либо $\psi'$ следует за $txbegin$ действием $\psi'' \in S_i$ потока $t$ в $H_3$: $\psi'' \prec_{H_3} \psi'$ и $\psi'' \prec_{S_i} \psi'$. Так как $\psi \in H_1$, то $\psi \prec_H \psi''$. Из этого следует, что $\psi \prec_{S_i} \psi''$, $\psi'', \psi' \in S''$ и $\psi'' \prec_{S_{i+1}} \psi'$. Из построения $S_{i+1}$ следует, что $\psi_a \prec_{S_{i+1}} \psi''$. Следовательно, $\psi_a \prec_{S_{i+1}} \psi'$. 
\end{itemize}

\end{myproof}
\begin{lemma}\label{sufficiency5}
Если $\mathcal{T}_C \sqsubseteq_{tms} \mathcal{T}_A$ и $\mathcal{T}_A$ удовлетворяет 1 и 2 свойствам замкнутости, тогда $\forall \; \tau \in \llbracket P, \mathcal{T}_C\rrbracket(s)$ $\exists \; \tau' \in \llbracket P, \mathcal{T}_A \rrbracket(s)$ такие, что $(\tau'|_{\neg trans} = \tau|_{\neg trans}) \land (\forall \; t \; (\tau'|_t)|_{obs} = (\tau|_t)|_{obs})$.\end{lemma}
\begin{myproof}
Пусть $H = history(\tau)$. По предположению леммы $\mathcal{T}_C \sqsubseteq_{tms} \mathcal{T}_A$. Следовательно $\exists \; H^c \in comp(H)|_{\neg live}$ и $\exists \; S \in \mathcal{T}_A$ такие, что $H^c|_{com} \sqsubseteq_{op} S$. Тогда $H^c = (H|_{\neg live})H'$, для некоторой последовательности действий $H'$, состоящей из $committed$ и $aborted$ действий.  Пусть $\tau^c = \tau_0H'$, где след $\tau_0$ получен из следа $\tau$ удалением всех действий действующих транзакций. Следовательно, $history(\tau^c) = H^c$.

Покажем, что $\tau^c \in \llbracket P \rrbracket(s)$. Согласно определению множества $A'(P)$ (рисунок \ref{fig:actions}), множество $\llbracket P\rrbracket(s)$ содержит префиксы следа $\tau \in \llbracket P\rrbracket(s)$. Кроме того, $\llbracket P\rrbracket(s)$ допускает произвольное прерывание и фиксацию транзакций. Так как след $\tau^c$ получен из $\tau$ удалением только некоторых последних транзакций потоков и завершением транзакций, ожидающих фиксацию, то $\tau^c \in \llbracket P\rrbracket(s)$. Кроме того, $\tau^c|_{\neg trans} = \tau|_{\neg trans}$ и $(\tau|_t)|_{obs}$ --- префикс $(\tau^c|_t)|_{obs}$. Пусть $\tau^{na} = \tau^c|_{\neg abortact}$. Согласно утверждению \ref{statement1}
$\tau^{na} \in \llbracket P \rrbracket(s)$. Так как $(H^c|_{\neg abortact})|_{\neg abortedtx} = H^c|_{com} \sqsubseteq_{op} S$, то по лемме \ref{sufficiency4}
существует история $S' \in addab(S)$ такая, что $history(\tau^{na}) = H^c|_{\neg abortact} \sqsubseteq_{op} S'$. Так как $S \in \mathcal{T}_A$ и $\mathcal{T}_A$ замкнута относительно мгновенного прерывания транзакций, то $S' \in \mathcal{T}_A$. Так как $\tau^{na} \in \llbracket P \rrbracket(s)$, тогда по лемме \ref{sufficiency3} 
существует след $\tau'' \in \llbracket P \rrbracket(s)$ такой, что $history(\tau'') = S',$ $$\tau''|_{\neg trans} = \tau^{na}|_{\neg trans} = \tau^c|_{\neg trans} = \tau|_{\neg trans},$$
и $\tau''|_t = \tau^{na}|_t$. Пусть $\tau'$ --- след, полученный из $\tau''$ удалением последних ответов на запросы каждого потока в $H'$. Тогда $$\tau'|_{\neg trans} = \tau''|_{\neg trans} = \tau|_{\neg trans},$$ $\tau' \in \llbracket P\rrbracket(s)$. Так как $\mathcal{T}_A$ замкнута относительно удаления ответов на запросы, то $history(\tau') \in \mathcal{T}_A$.

Покажем, что $(\tau'|_t)|_{obs} = (\tau|_t)|_{obs}$. Так как $\tau''|_t = \tau^{na}|_t$, то $$(\tau''|_t)|_{obs} = (\tau^{na}|_t)|_{obs} = ((\tau^c|_{\neg abortact})|_t)|_{obs} = (\tau^c|_t)|_{obs}.$$ Следовательно, $(\tau|_t)|_{obs}$ --- префикс $(\tau''|_t)|_{obs}$. След $\tau'$ получен из следа $\tau''$ удалением действий $H'$. Из этого следует, что $(\tau|_t)|_{obs} = (\tau'|_t)|_{obs}$.
\end{myproof}
  
\begin{lemma}\label{necessity1}
Пусть $\mathcal{T}_C$ и $\mathcal{T}_A$ --- конкретная и абстрактная транзакционная память такие, что $\mathcal{T}_C \preceq \mathcal{T}_A$ и $\mathcal{T}_A$ удовлетворяет 3 и 4 свойствам замкнутости. Тогда $\forall H \in \mathcal{T}_C$ $\exists H^c \in comp(H |_{\neg live})$, $S \in \mathcal{T}_A$: $H^c|_{com} \, \sqsubseteq_{op} S$.
\end{lemma}
\begin{myproof} Выберем целое значение $u \neq 1$, которого нет в $H$. Введем следующие обозначения:
\begin{itemize}
\item[--] $m$ --- наибольший идентификатор потока, встречающийся в $H$. 
\item[--] $k^t$ --- число транзакций потока $t$ в $H$, то есть число $(\_,t,txbegin)$ действий в $H$. 
\item[--] Разделим $H|_t$ на $k^t$ подпоследовательностей: $H|_t$ = $H^t_{1} \ldots H^t_{k^t}$, где $H^t_i$ состоит из действий $i$ транзакции потока $t$, $H^t_i(1)$ = $(\_,t, txbegin)$.
\item[--] $c^t_i$ --- результат $i$ транзакции потока $t$, то есть $c^t_i = committed$ или $c^t_i = aborted$. Если транзакция не завершена, то значение $c^t_i$ не определено.
\item[--] $q^t_i$ --- число $call$ действий в $H^t_i$.
\item[--] $(\_,t, call \, o^t_{i,j}.f^t_{i,j}(n^t_{i,j}))$ --- $j$ $call$ действие в $H^t_i$. 
\item[--] $(\_,t, ret(r^t_{i,j}) \, o^t_{i,j}.f^t_{i,j})$ --- $j$ $ret$ действие в $H^t_i$. Если запрос $(\_,t, call \, o^t_{i,j}.f^t_{i,j}(n^t_{i,j}))$ завершается прерыванием транзакции, тогда $r^t_{i,j}$ = $aborted$. Если нет ответа на запрос, то есть транзакция действующая и $(\_,t, call \, o^t_{i,j}.f^t_{i,j}(n^t_{i,j}))$ --- последнее действие, тогда $r^t_{i,j}$ = $u$.
\item[--] $lasttx(t, i, t')$ --- число завершенных транзакций потока $t'$ в $H$ до начала $i$ транзакции потока $t$, то есть число $(\_,t', committed)$ и $(\_,t', aborted)$ действий предшествующих $H^t_{i}(1)$ = $(\_,t,txbegin)$ действию.
\end{itemize}
\begin{figure}
\begin{flalign*}
 GP^t_i  &= z^t_{i,1} := g^1_{lasttx(t,i,1)}; if \left(z^t_{i,1} \neq 1 \right) then \, fault; \\
 &\mathrel{\phantom{=}} \ldots \\ 
 &\mathrel{\phantom{=}} z^t_{i,m} := g^m_{lasttx(t,i,m)}; if \left(z^t_{i,m} \neq 1 \right) then \, fault
\end{flalign*}
\begin{itemize}
\item[--] Если $H^t_{i}$ --- зафиксированная транзакция или прерванная и видимая транзакция, тогда
\begin{alignat}{2}
     CP^t_i =&\quad \omega^t_{i} := &\; atomic\{&y^t_{i,1} := o^t_{i,1}.f^t_{i,1}(n^t_{i,1}); \; if \left (y^t_{i,1} \neq r^t_{i,1}\right) then \; fault; \nonumber \\
         &           &&\ldots \nonumber \\
         &           &&y^t_{i,q^t_i} := o^t_{i,q^t_i}.f^t_{i,q^t_i}(n^t_{i,q^t_i}); \; if \left (y^t_{i,q^t_i} \neq r^t_{i,q^t_i}\right) then \; fault\} \nonumber \\
         &\quad \mathrlap{if \left(\omega^t_{i} \neq c^t_{i} \right) then \; fault \; else \; g^t_{i} := 1} \nonumber
\end{alignat}
\item[--] Если $H^t_{i}$ --- действующая транзакция или прерванная и не видимая транзакция, тогда
\begin{alignat}{2}
     CP^t_i =&\quad \omega^t_{i} := &\; atomic\{&y^t_{i,1} := o^t_{i,1}.f^t_{i,1}(n^t_{i,1}); \nonumber \\
         &           &&\ldots \nonumber \\
         &           &&y^t_{i,q^t_i} := o^t_{i,q^t_i}.f^t_{i,q^t_i}(n^t_{i,q^t_i}); \nonumber \\
         &           &&fault \} \nonumber
\end{alignat}
\item[--] Если $H^t_{i}$ --- ожидающая фиксации транзакция, тогда 
\begin{alignat}{2}
     CP^t_i =&\quad \omega^t_{i} := &\; atomic\{&y^t_{i,1} := o^t_{i,1}.f^t_{i,1}(n^t_{i,1}); \; if \left (y^t_{i,1} \neq r^t_{i,1}\right) then \; fault; \nonumber \\
         &           &&\ldots \nonumber \\
         &           &&y^t_{i,q^t_i} := o^t_{i,q^t_i}.f^t_{i,q^t_i}(n^t_{i,q^t_i}); \; if \left (y^t_{i,q^t_i} \neq r^t_{i,q^t_i}\right) then \; fault\} \nonumber
\end{alignat}
\end{itemize}
\caption{Построение $GP^t_i$ и $CP^t_i$ команд}
\label{fig:commands}
\end{figure}
Для каждого потока $t$ = $1..m$ построим последовательность команд $$C^t_H = GP^t_1;CP^t_1;GP^t_2;CP^t_2;\ldots;GP^t_{k^t};CP^t_{k^t},$$ где $GP^t_i$ и $CP^t_i$ определены на рисунке ~\ref{fig:commands}.
Переменные $g^t_i$ --- глобальные, все остальные переменные --- локальные. Переменная $g^t_i$ используется для мониторинга порядка выполнения транзакций. Значение $g^t_i$ изменяется только потоком $t$ и используется для оповещения о завершении $i$ транзакции потока $t$. Переменная $z^t_{i,t'}$ используется для записи завершения $lasttx(t, i, t')$ транзакции потока $t'$, предшествующей запуск $i$ транзакции потока $t$. Так как значение $lasttx(t, i, t')$ может быть равно нулю, введём фиктивную переменную $g^t_0$ для каждого потока $t$. Переменная $\omega^t_i$ хранит информацию о статусе завершения $i$ транзакции потока $t$ (committed или aborted). Переменная $y^t_{i,j}$ записывает результат $j$ вызова метода объекта в $i$ транзакции потока $t$. 

Команда $GP^t_i;CP^t_i$ начинается с чтения сигналов ($g^t_{lasttx(t,i,t')}$) последней транзакции каждого потока $t'$, завершённой до начала $i$ транзакции потока $t$. Далее выполняется атомарный блок, в котором вызывается последовательность методов объектов транзакцией $H^t_i$. После завершения атомарного блока команда объявляет завершение транзакции. Определим программу $P_H$ следующим образом: $$P_H = C^1_H \; \parallel \ldots \parallel C^m_H.$$

Далее построим след $\tau$ программы $P_H$. Для начала построим $\tau^t$ для каждой последовательной команды $C^t_H$. Рассмотрим множество следов $A(C^t_H)t$ команды $C^t_H$, и пусть $\tau^t \in A(C^t_H)t$ --- максимальный след без $fault$ команды такой, что $H|_t$ = $history(\tau^t)$. След $\tau^t$ существует в связи с конструкцией $C^t_H$ и определением множества следов последовательной команды (рисунок \ref{fig:actions}). Во множестве $A(C^t_H)t$ существует след для каждого возможного параметра, результата вызова метода объекта и атомарного блока в $C^t_H$. В частности, $A(C^t)$ содержит след, в котором параметры, результат вызова методов объектов и атомарного блока такие же, как и в $H|_t$. Далее разделим каждый след $\tau^t$ на $|H|_t|$ подпоследовательностей: 
\begin{equation}\label{eq:tau_t}
\tau^t = \tau^t_1\ldots\tau^t_{|H|_t|}.
\end{equation}
Для каждого потока $i$ = $1..|H|_t|$ существует одно действие интерфейса $\psi^t_i$ в $\tau^t_i$, и выполняются условия, изображенные на рисунке \ref{fig:subtraces}. Это определяет след $\tau^t_i$ единственным образом и гарантирует, что, если след $\tau^t_i$ заканчивается $\psi^t_i = (\_,t,txbegin)$, то он содержит все действия, которые используются для чтения сигнализирующих глобальных переменных, предшествующих действию $\psi^t_i$ в $\tau^t$. Желаемый след строится с помощью чередования подпоследовательностей следов $\tau^1,\ldots,\tau^m$ согласно порядку, обусловленному историей $H$. Формально 
\begin{equation}\label{eq:tau}
\tau = \tau^{t_1}_{j_1} \ldots \tau^{t_{|H|}}_{j_{|H|}},
\end{equation}
где $H(i)$ = $(\_, t_i, \_)$ и $j_i$ = $|(H \downharpoonleft_i)|_{t_i}|.$ По построения $history(\tau)$ = $H$.
\begin{figure}
\begin{align*}
  \tau^t_i=\begin{cases}
    \_\psi^t_i, & \psi^t_i \in \{(\_,t,txbegin), (\_,t,call \; o.f(n)), (\_,t, txcommit)\};\\
    \psi^t_i, & \psi^t_i = (\_,t, OK); \\
    \psi^t_i(\_,t,y^t_{i,\_} := n), & \psi^t_i = (\_,t, ret(n) \; o.f) \land txof(\psi^t_i, \tau^t) \in live(\tau^t); \\
    \mathrlap{\psi^t_i(\_,t,y^t_{i,\_} := n)(\_,t,assume(y^t_{i,\_} = r^t_{i,\_})),}\\
                                    & \psi^t_i = (\_,t, ret(n) \; o.f) \land txof(\psi^t_i, \tau^t) \notin live(\tau^t); \\
    \mathrlap{\psi^t_i(\_,t,\omega_i := c^t_i)(\_,t,assume(\omega_i = c^t_i))(\_,t,g^t_i := 1),}\\
                                    & \psi^t_i \in \{(\_,t,committed), (\_,t,aborted))\}.       
  \end{cases}
\end{align*}
\caption{Построение $\tau^t_i$}
\label{fig:subtraces}
\end{figure}
Так как $\tau^t \in A(C^t_H)t$, то $\tau \in A(P_H)t$. Пусть $s$ --- состояние программы, в которой все локальные переменные инициализированы целым числом $u$, а глобальные переменные $g^t_i = 0$ при $i \neq 0$ и $g^t_0 = 1$. $eval(s,\tau) \neq \emptyset$ по построению $\tau$. Так как $history(\tau) = H \in \mathcal{T}_C$, то $\tau \in \llbracket P_H \rrbracket(s,\mathcal{T}_C)$. Так как $\tau \in \llbracket P_H \rrbracket(s,\mathcal{T}_C)$ и $\mathcal{T}_C \preceq \mathcal{T}_A$, то по определению \ref{def1} % изменить ссылку на опр 
существует след $\tau' \in \llbracket P_H \rrbracket(s,\mathcal{T}_A)$ такой, что $\tau'|_{\neg trans}$ = $\tau|_{\neg trans}$ и $S_1 = history(\tau') \in \mathcal{T}_A$.

Пусть $T$ и $T'$ --- $i$ транзакции потока $t$ в $\tau|_t$ и $\tau'|_t$ соответственно. Так как $\tau'|_{\neg trans}$ = $\tau|_{\neg trans}$, то либо транзакции $T$ и $T'$ запускается одинаковыми командами, либо $T'$ не существует. Проанализируем зависимость между этими транзакциями, основываясь на конструкции команды $C^t_H$ (рисунок \ref{fig:commands}):
\begin{itemize}
\item[--] Если транзакция $T$ завершена, тогда транзакция $T'$ тоже завершена, так как после завершения транзакции переменной $g^t_i$ присваивается новое значение и $\tau'|_{\neg trans}$ = $\tau|_{\neg trans}$. Завершённая транзакция $T$ --- зафиксированная тогда и только тогда, когда $T'$ --- зафиксированная. В данном случае проверки, выполненные внутри соответствующих атомарных блоков, доказывают, что возвращаемые результаты транзакционных действий внутри $T$ и $T'$ совпадают.
% может заменить слово доказывает на утверждает ?
\item[--] Если транзакция $T$ --- действующая, тогда присутствие команды $fault$ до завершения атомарного блока доказывает, что транзакция $T'$ может быть действующей, прерванной или не существовать. 
\item[--] Если транзакция $T$ ожидает фиксацию, тогда у транзакции $T'$ может быть любой статус, или она может не существовать. Однако, если $T$  --- видимая, тогда проверки внутри атомарного блока доказывают, что результаты транзакционных действий внутри $T$ и $T'$ совпадают.
\end{itemize}

Пусть $H_1 = (H|_{\neg live})|_{\neg abortedtx}$ и $S_2 = (S_1|_{\neg live})|_{\neg abortedtx}$. Так как $S_1 \in \mathcal{T}_A$ и $\mathcal{T}_A$ замкнута относительно операции удаления действующих и прерванных транзакций, то $S_2 \in \mathcal{T}_A$. Пусть $p'_t$ и $p''_t$ --- индексы последних $txcommit$ или $committed$ действий в $H_1|_t$ и $S_2|_t$ соответственно. В случае отсутствия этих действий, индексы равны 0. Пусть $p_t=min(p'_t,p''_t)$. Из приведенного анализа следует, что $\forall \; t \; (H_1|_t)\downharpoonleft_{p_t} \equiv (S_2|_t)\downharpoonleft_{p_t}$. Пусть $S_3$ --- история, полученная из $S_2$ переименованием идентификаторов действий таким образом, что $S_3 \equiv S_2$, $\forall \; t \; (H_1|_t)\downharpoonleft_{p_t} = (S_3|_t)\downharpoonleft_{p_t}$, и все действия в $S_3$, которые не принадлежат $(S_2|_t)\downharpoonleft_{p_t} \; \forall \; t$, имеют идентификаторы, которые не встречаются в $H$. Так как $S_2 \in \mathcal{T}_A$ и $\mathcal{T}_A$ замкнута относительно операции переименования идентификаторов, то $S_3 \in \mathcal{T}_A$.

Так как $S_3 \in \mathcal{T}_A$ и $\mathcal{T}_A$ --- замкнута относительно операции завершения транзакций, ожидающих фиксации, получаем, что существует история $S_4 \in nicomp(S_3) \cap \mathcal{T}_A$. Пусть $S'_3$ --- подпоследовательность $S_4$, которая содержит только $committed$ или $aborted$ действия, которых нет в $S_3$. % т.е. эти действия - завершение транз
Идентификаторы действий в $S'_3$ не встречаются в $H$. Пусть $S''_3$ --- подпоследовательность $committed$ действий в $S_3$, которых нет в $H_1$. Построим требуемую историю $H^c$ с помощью прерывания всех ожидающих фиксацию транзакций истории $(H|_{\neg live})S''_3S'_3$. Пусть $H^c = (H|_{\neg live})S''_3S'_3H_a$, где $H_a$ состоит из действий $(\_, t, aborted)$ для каждого потока $t$, который завершается транзакцией, ожидающей фиксации, в $(H|_{\neg live})S''_3S'_3$. У этих действий есть уникальные идентификаторы, которые не появляются в $H$. $H^c \in comp(H|_{\neg live})$ по следующим причинам: 
\begin{enumerate}[label=(\roman*)]
\item $S''_3$ завершает транзакции, зафиксированные в $S_1$, но ожидающие фиксацию в $H$.  
\item $S'_3$ завершает транзакции, ожидающие фиксацию в $H$ и $S_1$.
\item $H_a$ прерывает транзакции, ожидающие фиксацию в $H$, которые могут быть действующими, прерванными или не существовать в $S_1$.
\end{enumerate}

Пусть $S = S_4|_{com}$. $S \in \mathcal{T}_A$, так как $S_4 \in \mathcal{T}_A$ содержит только завершенные транзакции, и транзакционная память $\mathcal{T}_A$ замкнута относительно удаления действующих и прерванных транзакций. Докажем, что $H^c|_{com} \sqsubseteq_{op} S$. Для начала покажем, что $\forall \; t \; (H^c|_t)|_{com} = S|_t$, рассмотрев следующие случаи:
\begin{itemize}
\item[--] $H|_t$ не содержит транзакций, ожидающих фиксацию. Тогда $p'_t = p''_t$, $H_1|_t = S_3|_t$ и $S'_3 = S''_3 = H_a = \varepsilon$. Следовательно, $$(H^c|_t)|_{com} = (H_1|_t)|_{com} = (S_3|_t)|_{com} = (S_4|_t)|_{com} = S|_t.$$
\item[--] $H|_t$ завершается транзакцией, ожидающей фиксацию, и $(S''_3S'_3H_a)|_t = S''_3|_t = (\_,t,committed)$. Тогда $H_1|_t = (H_1|_t)\downharpoonleft_{p_t}$ и $S_3|_t = ((S_3|_t)\downharpoonleft_{p_t})(S''_3|_t)$. Следовательно, 
\begin{align*}
(H^c|_t)|_{com} = ((H_1|_t)(S''_3|_t))|_{com} = (((H_1|_t)\downharpoonleft_{p_t})(S''_3|_t))|_{com} = \\
(((S_3|_t)\downharpoonleft_{p_t})(S''_3|_t))|_{com} = (S_3|_t)|_{com} = (S_4|_t)|_{com} = S|_t.
\end{align*}
\item[--] $H|_t$ завершается транзакцией, ожидающей фиксацию, и $(S''_3S'_3H_a)|_t = S'_3|_t$. Тогда $H_1|_t = S_3|_t$, так как $p'_t = p''_t$. Следовательно, 
\begin{align*}
(H^c|_t)|_{com} = ((H_1|_t)(S'_3|_t))|_{com} = ((S_3|_t)(S'_3|_t))|_{com} = (S_4|_t)|_{com} = S|_t.
\end{align*}
\item[--] $H|_t$ завершается транзакцией, ожидающей фиксацию, и $(S''_3S'_3H_a)|_t$ = $H_a|_t$ = $(\_, t, aborted)$. Тогда $((H_1|_t)(H_a|_t))|_{com} = ((H_1|_t)\downharpoonleft_{p_t})|_{com}$ и $S_3|_t = (S_3|_t)\downharpoonleft_{p_t}$. Следовательно,
\begin{align*}
(H^c|_t)|_{com} = ((H_1|_t)(H_a|_t))|_{com} = ((H_1|_t)\downharpoonleft_{p_t})|_{com} =\\
((S_3|_t)\downharpoonleft_{p_t})|_{com} = (S_3|_t)|_{com} = (S_4|_t)|_{com} = S|_t. 
\end{align*}
\end{itemize}

Эти рассуждения доказывают, что $\forall \; t \; (H^c|_t)|_{com} = S|_t$. Для каждой завершённой транзакции $T$ в $\tau$ значение $g^t_i = 1$, и значение этой переменной читается до начала транзакции $T'$, которая запускается после завершения $T$. Следовательно транзакция в $\tau'$, соответствующая $T$, завершается до начала транзакции в $\tau'$, соответствующей $T'$. Следовательно порядок выполнения транзакций в $H^c$ сохраняется в $S$, откуда следует, что $H^c|_{com} \sqsubseteq_{op} S$. 
\end{myproof}
\begin{lemma}\label{necessity2}
Пусть $\mathcal{T}_C$ и $\mathcal{T}_A$ --- конкретная и абстрактная транзакционная память такие, что $\mathcal{T}_C \preceq \mathcal{T}_A$ и $\mathcal{T}_A$ удовлетворяет 3 и 4 свойствам замкнутости. Пусть $H = H'\psi$, где $\psi$ --- ответ на запрос, при этом $\psi \notin \{(\_,\_,committed),(\_,\_,aborted)\}$. Тогда $\exists H^c \in cTMSpast(H)$ и $\exists S \in \mathcal{T}_A$ такие, что $H^c \sqsubseteq_{op} S$.
\end{lemma}
\begin{myproof}
Для доказательства данной леммы будут использованы ранее введенные обозначения. Для каждого потока $t$ = $1..m$ построим последовательность команд $$C^t_H = GP^t_1;CP^t_1;GP^t_2;CP^t_2;\ldots;GP^t_{k^t};CP^t_{k^t}.$$

\begin{figure}
\begin{flalign*}
 GP^t_i  &= z^{t_0}_{i,1} := g^1_{lasttx(t_0,i,1)}; if \left(z^{t_0}_{i,1} \neq 1 \right) then \, mismatch := 1; \\
 &\mathrel{\phantom{=}} \ldots \\ 
 &\mathrel{\phantom{=}} z^{t_0}_{i,m} := g^m_{lasttx(t_0,i,m)}; if \left(z^{t_0}_{i,m} \neq 1 \right) then \, mismatch := 1
\end{flalign*}
\begin{itemize}
\item[--] Для $i \neq k^{t_0}$ команда $CP^{t_0}_i$ построена следующим образом:
\begin{alignat}{2}
     CP^{t_0}_i =&\quad \omega^{t_0}_{i} := &\; atomic\{&y^{t_0}_{i,1} := o^{t_0}_{i,1}.f^{t_0}_{i,1}(n^{t_0}_{i,1}); \nonumber \\ 
     &&& if \left (y^{t_0}_{i,1} \neq r^{t_0}_{i,1}\right) then \; mismatch := 1; \nonumber \\
         &           &&\ldots \nonumber \\
         & && y^{t_0}_{i,q^{t_0}_i} := o^{t_0}_{i,q^{t_0}_i}.f^{t_0}_{i,q^{t_0}_i}(n^{t_0}_{i,q^{t_0}_i}); 
         \nonumber \\ 
         &&& if \left (y^{t_0}_{i,q^{t_0}_i} \neq r^{t_0}_{i,q^{t_0}_i}\right) then \; mismatch := 1\} \nonumber \\
         &\quad \mathrlap{if \left(\omega^{t_0}_{i} \neq c^{t_0}_{i} \right) then \; mismatch := 1 \; else \; g^{t_0}_{i} := 1} \nonumber
\end{alignat}
\item[--] Команда $CP^{t_0}_{k^{t_0}}$ построена следующим образом:
\begin{alignat}{2}
     CP^{t_0}_{k^{t_0}} =&\quad \omega^{t_0}_{k^{t_0}} := &\; atomic\{&y^{t_0}_{k^{t_0},1} := o^{t_0}_{k^{t_0},1}.f^{t_0}_{k^{t_0},1}(n^{t_0}_{k^{t_0},1}); \nonumber \\ 
     &&& if \left (y^{t_0}_{k^{t_0},1} \neq r^{t_0}_{k^{t_0},1}\right) then \; mismatch := 1; \nonumber \\
         &           &&\ldots \nonumber \\
         & && y^{t_0}_{k^{t_0},q^{t_0}_{k^{t_0}}} := o^{t_0}_{k^{t_0},q^{t_0}_{k^{t_0}}}.f^{t_0}_{k^{t_0},q^{t_0}_{k^{t_0}}}(n^{t_0}_{k^{t_0},q^{t_0}_{k^{t_0}}}); 
         \nonumber \\ 
         &&& if \left (y^{t_0}_{k^{t_0},q^{t_0}_{k^{t_0}}} \neq r^{t_0}_{k^{t_0},q^{t_0}_{k^{t_0}}}\right) then \; mismatch := 1 \nonumber \\
         &&& if \left(mismatch \neq 1 \right) then \; fault \} \nonumber
\end{alignat}
\end{itemize}
\caption{Построение $GP^{t_0}_i$ и $CP^{t_0}_i$ команд}
\label{fig:commands_t0}
\end{figure}

Пусть $\psi = (\_,t_0,\_)$. Для $t \neq t_0$ $GP^t_i$ и $CP^t_i$ определены на рисунке ~\ref{fig:commands}, а для $t = t_0$ $GP^t_i$ и $CP^t_i$ определены на рисунке ~\ref{fig:commands_t0}. Для проверки результатов вызовов методов объектов транзакционной памяти в потоке $t_0$ используется локальная переменная $mismatch$. Если результат не соответствует $H|_{t_0}$, тогда поток $t_0$ в программе $P_H$ устанавливает значение переменной $mismatch$ равным единице, $mismatch = 1$. В конце выполнения программы поток проверяет значение этой переменной и прерывает выполнение, если локальные наблюдения потока $t_0$ совпадают с историей $H|_{t_0}$, то есть $mismatch \neq 1$.

Для того чтобы построить след $\tau$ программы $P_H$, построим след $\tau^t$ для каждой команды $C^t_H$, $t = 1..m$. Рассмотрим множество следов $A(C^t_H)$. Пусть $\tau^t \in A(C^t_H)$ --- максимальный след в $A(C^t_H)$ такой, что $H|_t = history(\tau^t)$. След $\tau^{t_0}$ завершается командой $fault$. Далее разделим каждый след $\tau^t$ на $|H|_t|$ подпоследовательностей, как было определено в формуле \eqref{eq:tau_t}. Условия, изображенные на рисунке \ref{fig:subtraces}, изменяются для случая $t=t_0$ и $\psi^{t_0}_i = \psi$:
\begin{align}
\tau^t_i = &\quad \psi(\_, t, y^t_{i,\_} := n)(\_, t, assume(y^t_{i,\_} = \nonumber \\
&\qquad \qquad r^t_{i,\_}))(\_, t, assume(mismatch \neq 1))(\_, t, fault). \nonumber
\end{align}
Желаемый след $\tau$ строится с помощью чередования подпоследовательностей следов $\tau^1,\ldots,\tau^m$ согласно порядку, обусловленному историей $H$, как было определено в формуле \eqref{eq:tau}. По построения $history(\tau)$ = $H$.

Так как $\tau^t \in A(C^t_H)t$, то $\tau \in A(P_H)t$. Пусть $s$ --- состояние программы, в которой все локальные переменные инициализированы целым числом $u$, а глобальные переменные $g^t_i = 0$ при $i \neq 0$ и $g^t_0 = 1$. $eval(s,\tau) \neq \emptyset$ по построению $\tau$. Так как $history(\tau) = H \in \mathcal{T}_C$, то $\tau \in \llbracket P_H \rrbracket(s,\mathcal{T}_C)$. Так как $\tau$ завершается $fault$ действием и $\mathcal{T}_C \preceq \mathcal{T}_A$, то по определению \ref{def1} % изменить ссылку на опр
существует след $\tau' \in \llbracket P_H \rrbracket(s,\mathcal{T}_A)$, который тоже завершается действием $fault$ потока $t_0$. $S_1 = history(\tau') \in \mathcal{T}_A$.

Так как оба следа $\tau$ и $\tau'$ завершаются командой $fault$ потока $t_0$, то проверки внутри потоков указывают на то, что \begin{equation} \label{eq:hist_fault}
(H|_{\neg abortedtx})|_{t_0} \equiv ({S_1}|_{\neg abortedtx})|_{t_0}. 
\end{equation}
Рассмотрим потоки $t \neq t_0$ и $t'$. Пусть $T$ и $T_1$ --- i транзакции в историях $H|_t$ и ${S_1}|_t$ соответственно. Пусть $T'$ и $T'_1$ --- j транзакции в историях $H|_{t'}$ и ${S_1}|_{t'}$ соответственно ($T_1$ и $T'_1$ могут не существовать). Из построения $P_H$ следует:
\begin{enumerate}
\item Так как $\tau$, $\tau'$ содержат только одну команду $fault$, то транзакция T не может быть действующей или прерванной, но не видимой (рисунок \ref{fig:commands}). Следовательно, если $T_1$ видимая транзакция, то транзакция $T$ тоже видимая. Кроме того, проверки внутри атомарных блоков доказывают, что результаты вызовов методов объектов в транзакциях $T$ и $T'$ совпадают.  
\item Если $T' \prec_H T$ и транзакция $T_1$ существует, тогда существует транзакция $T'_1$, и $T'_1 \prec_{S_1} T_1$, при этом $T'$ --- зафиксированная транзакция тогда и только тогда, когда $T'_1$ --- зафиксированная транзакция. Это обусловлено тем, что перед запуском транзакции $T_1$ в $\tau'$ осуществляется проверка равенства значения переменной $g^{t'}_j$ единице. $g^{t'}_j = 1$, если пройдены проверки внутри транзакции $T'_1$ и проверка статуса транзакции $T'_1$.   
\end{enumerate}

Пусть $S_2 = (S_1|_{\psi\cup{\neg live}})|_{\neg abortedtx}$, где $\cdot|_{\psi \cup {\neg live}}$ --- проекция на действия не действующих транзакций, за исключением транзакции действия $\psi$. Так как $S_1 \in \mathcal{T}_A$ и транзакционная память $\mathcal{T}_A$ замкнута относительно удаления действующих и прерванных транзакций, то $S_2 \in \mathcal{T}_A$. Так как $S_2 \in \mathcal{T}_A$ и $\mathcal{T}_A$ замкнута относительно завершения транзакций, ожидающих фиксацию, то существует история $S_3 \in nicomp(S_2) \cap \mathcal{T}_A$. Пусть $S_4 = S_3|_{\psi \cup com}$, где $\cdot|_{\psi \cup com}$ --- проекция на зафиксированные транзакции и транзакции действия $\psi$. Так как $S_3 \in \mathcal{T}_A$ не содержит транзакций, ожидающих фиксацию, и $\mathcal{T}_A$ замкнута относительно удаления действующих и прерванных транзакций, то $S_4 \in \mathcal{T}_A$.

Пусть $H_1$ --- подпоследовательность истории $H$, состоящая из транзакций, для которых соответствующие транзакции в $S_1$ включены в $S_4$. Следовательно, исходя из первого пункта приведённого выше анализа и формулы \eqref{eq:hist_fault} получаем: $$ tx(H_1) \subseteq \{txof(\psi,H) \} \cup visible(H).$$
Рассмотрим $T, T' \in tx(H_1)$ такие, что $T' \prec_{H_1} T$. Тогда существуют соответствующие им транзакции $T_1,T'_1 \in tx(S_1)$, из пункта 2 следует, что $T'_1 \prec_{S_1} T_1$. Из отношения $T'_1 \prec_{S_1} T_1$ следует, что $T'_1$ --- завершённая транзакция. В то же время транзакция $T'_1$ включена в историю $S_4$, которая содержит только зафиксированные транзакции и транзакцию $txof(\psi, S1)$. Отсюда следует, что $T'_1$ --- зафиксированная транзакция. Как было отмечено выше, $T'_1$ --- зафиксированная транзакция тогда и только тогда, когда $T'$ --- зафиксированная транзакция. Следовательно $T' \in committed(H)$. Докажем в обратную сторону. Рассмотрим $T \in tx(H_1)$, $T' \in committed(H)$ такие, что $T' \prec_H T$. Докажем, что $T' \in tx(H_1)$. Так как $T \in tx(H_1)$, то существует cоответствующая ей транзакция $T_1 \in tx(S_1)$. Тогда, как было отмечено выше, существует соответствующая $T'$ зафиксированная транзакция $T'_1 \in tx(S_1)$. Следовательно $T'_1 \in tx(S_4)$, и $T' \in tx(H_1)$. По определению допустимой истории $H_1 \in TMSpast(H)$. % сделать ссылку на определение 

Пусть $H_1 = H'_1\psi$, $H^c \in ccomp(com(H'_1)\psi)$. Тогда $H^c \in cTMSpast(H)$. Из равенства \ref{eq:hist_fault} следует, что $(H_1|_{t_0}) \equiv (S_4|_{t_0})$. Пусть $p_t$ --- индекс последнего $txcommit$ действия в $S_4|_t$ при $t \neq t_0$. Из пунктов 1 и 2 следует, что $(H_1|_{t})\downharpoonleft {p_t} \equiv (S_4|_{t})\downharpoonleft {p_t}$ для $t \neq t_0$. Так как история $H_1$ может содержать транзакцию, ожидающую фиксацию, которой будет соответствовать зафиксированная транзакция в $S_4$, то $H^c|_{t} \equiv S_4|_{t} \forall t$. Пусть $S$ --- история, полученная из $S_4$ переименованием идентификаторов действий таким образом, что $\forall t \; H^c|_t = S|_t$. Так как $S_4 \in \mathcal{T}_A$ и $\mathcal{T}_A$ замкнута относительно операции переименования идентификаторов действий, то $S \in \mathcal{T}_A$. Согласно пункту 2 порядок выполнения транзакций в $H^c$ сохраняется между соответствующими транзакциями в $S_1$. Отсюда следует, что $H^c \sqsubseteq_{op} S$ по определению. 
\end{myproof}
Приведём доказательство теоремы \ref{theorem1}.
\begin{mproof}
Доказательство данной теоремы состоит из доказательства необходимости и достаточности $TMS$ отношения между абстрактной и конкретной транзакционной памятью для отношения уточнения наблюдений.

Из лемм \ref{necessity1} и \ref{necessity2} следует, что если транзакционная память $\mathcal{T}_A$ удовлетворяет 3 и 4 свойствам замкнутости и $\mathcal{T}_C \preceq \mathcal{T}_A$, то $\mathcal{T}_C \sqsubseteq_{tms} \mathcal{T}_A$. Это доказывает необходимость $TMS$ отношения для уточнения абстрактной транзакционной памяти конкретной транзакционной памятью.

Покажем, что $TMS$ отношение достаточно для уточнения абстрактной транзакционной памяти конкретной транзакционной памятью. Благодаря лемме \ref{sufficiency5} осталось показать, что, если действие $fault$ встречается внутри следа $\tau \in \llbracket P, \mathcal{T}_C \rrbracket(s)$, то оно сохраняется внутри следа $\tau \in \llbracket P, \mathcal{T}_A \rrbracket(s)$.  

Рассмотрим след $\tau_0 \in \llbracket P, \mathcal{T}_C \rrbracket(s)$ такой, что $\tau_0 = \tau_1\psi\tau_2\chi$, где $\chi$ --- $fault$ действие транзакции потока $t_0$, и $\psi$ --- ответ за запрос, который не является $committed$ или $aborted$ действием и также является последним действие интерфейса потока $t_0$. Тогда $\tau_2|_{t_0}$ состоит из транзакционных действий потока $t_0$, у которых нет доступа к глобальным переменным. Следовательно, $\tau = \tau_1\psi(\tau_2|_{t_0})\chi \in \llbracket P, \mathcal{T}_C \rrbracket(s)$. По предположению теоремы $\mathcal{T}_C \sqsubseteq_{tms} \mathcal{T}_A$. Тогда существует история $H^C_{\psi} \in cTMSpast(history(\tau))$ и $S \in \mathcal{T}_A$ такие, что $H^C_{\psi} \sqsubseteq_{op} S$. По лемме \ref{sufficiency1} существует след $\tau_{\psi} \in \llbracket P \rrbracket(s)$ такой, что $history(\tau_{\psi})|_{\neg abortedtx} = H^C_{\psi}$ и $\tau_{\psi}|_{t_0} = \tau|_{t_0}$. По утверждению \ref{statement1} $\tau_{\psi}|_{\neg abortact} \in \llbracket P \rrbracket(s)$. Так как $history(\tau_{\psi})|_{\neg abortedtx} \sqsubseteq_{op} S$, то $history(\tau_{\psi}|_{\neg abortact})|_{\neg abortedtx} \sqsubseteq_{op} S$. По лемме \ref{sufficiency4} существует история $S'$ такая, что $history(\tau_{\psi}|_{\neg abortact}) \sqsubseteq_{op} S'$ и $S' \in addab(S)$. Так как $S \in \mathcal{T}_A$ и $\mathcal{T}_A$ замкнута относительно мгновенного завершения транзакций, то $S' \in \mathcal{T}_A$. Следовательно, по лемме \ref{sufficiency3} для следа $\tau_{\psi}|_{\neg abortact}$ существует след $\tau' \in \llbracket P, \mathcal{T}_A \rrbracket(s)$ такой, что $history(\tau') = S'$, $(\tau_{\psi}|_{\neg abortact})|_{t_0} = \tau'|_{t_0} =  (\tau_{\neg abortact})|_{t_0} = \_\chi$. Следовательно, действие $fault$ сохраняется в потоке $t_0$ следа $\tau' \in \llbracket P, \mathcal{T}_A \rrbracket(s)$ и $\mathcal{T}_C \preceq \mathcal{T}_A$. Достаточность $TMS$ отношения доказана.

$TMS$ отношение необходимо и достаточно для уточнения абстрактной транзакционной памяти конкретной транзакционной памятью.                 
\end{mproof}

\Conc




% Печать списка литературы (библиографии)
\printbibliography[heading=bibintoc%
    %,title=Библиография % если хочется это слово
]
% Файл со списком литературы: biblio.bib
% Подробно по оформлению библиографии: 
% см. документацию к пакету biblatex-gost
% http://ctan.mirrorcatalogs.com/macros/latex/exptl/biblatex-contrib/biblatex-gost/doc/biblatex-gost.pdf
% и огромное количество примеров там же:
% http://mirror.macomnet.net/pub/CTAN/macros/latex/contrib/biblatex-contrib/biblatex-gost/doc/biblatex-gost-examples.pdf

\end{document}
